#include "wifi_pentest_mcp_tools.h"

#include <algorithm>
#include <iomanip>
#include <sstream>
#include <cstring>

#include "esp_log.h"
#include "mbedtls/base64.h"
#include <cJSON.h>

namespace xiaozhi {

static const char* TAG = "WifiPentestMcpTools";

esp_err_t WifiPentestMcpTools::RegisterTools(McpServer& server) {
  ESP_LOGI(TAG, "Registering WiFi penetration testing tools");

  // Don't initialize the manager here - it will be initialized on first use
  // Initializing here causes issues because WiFi is already connected
  ESP_LOGI(TAG, "Pentest manager will be initialized on first tool call");

  // Tool 1: Scan targets
  server.AddTool("self.wifi_pentest.scan_targets",
                 "Scan available WiFi networks for target selection",
                 PropertyList(),
                 HandleScanTargets);

  // Tool 2: Deauth attack
  server.AddTool("self.wifi_pentest.deauth_attack",
                 "Deauthentication broadcast attack to disconnect clients",
                 PropertyList({
                     Property("target_bssid", kPropertyTypeString),
                     Property("target_ssid", kPropertyTypeString, std::string("")),
                     Property("duration_seconds", kPropertyTypeInteger, 10, 5, 300),
                     Property("frame_rate", kPropertyTypeInteger, 10, 1, 100)
                 }),
                 HandleDeauthAttack);

  // Tool 3: Rogue AP
  server.AddTool("self.wifi_pentest.rogue_ap",
                 "Rogue AP attack to capture WPA/WPA2 handshakes",
                 PropertyList({
                     Property("target_bssid", kPropertyTypeString),
                     Property("target_ssid", kPropertyTypeString),
                     Property("channel", kPropertyTypeInteger, 1, 13),
                     Property("duration_seconds", kPropertyTypeInteger, 60, 10, 600)
                 }),
                 HandleRogueApAttack);

  // Tool 4: PMKID capture
  server.AddTool("self.wifi_pentest.pmkid_capture",
                 "Capture PMKID from RSN Information Elements",
                 PropertyList({
                     Property("target_bssid", kPropertyTypeString),
                     Property("target_ssid", kPropertyTypeString, std::string("")),
                     Property("channel", kPropertyTypeInteger, 1, 13),
                     Property("duration_seconds", kPropertyTypeInteger, 30, 10, 300)
                 }),
                 HandlePmkidCapture);

  // Tool 5: DoS attack
  server.AddTool("self.wifi_pentest.dos_attack",
                 "Combined denial of service attack",
                 PropertyList({
                     Property("target_bssid", kPropertyTypeString),
                     Property("duration_seconds", kPropertyTypeInteger, 20, 5, 300)
                 }),
                 HandleDosAttack);

  // Tool 6: Stop attack
  server.AddTool("self.wifi_pentest.stop_attack",
                 "Stop currently running attack",
                 PropertyList(),
                 HandleStopAttack);

  // Tool 7: Export capture
  server.AddTool("self.wifi_pentest.export_capture",
                 "Export captured packets in PCAP or HCCAPX format",
                 PropertyList({
                     Property("format", kPropertyTypeString),
                     Property("base64_encode", kPropertyTypeBoolean, true)
                 }),
                 HandleExportCapture);

  // Tool 8: Get status
  server.AddTool("self.wifi_pentest.get_status",
                 "Get current attack status and statistics",
                 PropertyList(),
                 HandleGetStatus);

  ESP_LOGI(TAG, "WiFi pentest tools registered successfully");
  return ESP_OK;
}

ReturnValue WifiPentestMcpTools::HandleScanTargets(const PropertyList& properties) {
  ESP_LOGI(TAG, "Scanning WiFi networks");

  WifiPentestManager& manager = WifiPentestManager::GetInstance();
  std::vector<ScanResult> networks = manager.ScanNetworks();

  cJSON* result = cJSON_CreateObject();
  cJSON* networks_array = cJSON_CreateArray();

  for (const auto& network : networks) {
    cJSON* net = cJSON_CreateObject();
    cJSON_AddStringToObject(net, "ssid", network.ssid.c_str());
    cJSON_AddStringToObject(net, "bssid", FormatMacAddress(network.bssid).c_str());
    cJSON_AddNumberToObject(net, "channel", network.channel);
    cJSON_AddNumberToObject(net, "rssi", network.rssi);
    cJSON_AddStringToObject(net, "auth_mode", AuthModeToString(network.auth_mode).c_str());
    cJSON_AddItemToArray(networks_array, net);
  }

  cJSON_AddItemToObject(result, "networks", networks_array);
  return result;
}

ReturnValue WifiPentestMcpTools::HandleDeauthAttack(const PropertyList& properties) {
  ESP_LOGI(TAG, "Starting deauth attack");

  WifiPentestManager& manager = WifiPentestManager::GetInstance();

  // Initialize manager if not already initialized
  if (!manager.IsInitialized()) {
    esp_err_t ret = manager.Initialize();
    if (ret != ESP_OK) {
      cJSON* error = cJSON_CreateObject();
      cJSON_AddStringToObject(error, "error", "Failed to initialize pentest manager");
      return error;
    }
  }

  AttackConfig config;
  config.type = AttackType::DEAUTH;

  // Parse BSSID
  std::string bssid_str = properties["target_bssid"].value<std::string>();
  if (!ParseMacAddress(bssid_str, config.target_bssid)) {
    cJSON* error = cJSON_CreateObject();
    cJSON_AddStringToObject(error, "error", "Invalid BSSID format");
    return error;
  }

  // Optional SSID
  config.target_ssid = properties["target_ssid"].value<std::string>();
  config.duration_seconds = properties["duration_seconds"].value<int>();
  config.frame_rate = properties["frame_rate"].value<int>();

  // Start attack
  esp_err_t ret = manager.StartAttack(config);
  if (ret != ESP_OK) {
    cJSON* error = cJSON_CreateObject();
    cJSON_AddStringToObject(error, "error", "Failed to start attack");
    return error;
  }

  // Wait for completion
  while (manager.GetState() == PentestState::RUNNING) {
    vTaskDelay(pdMS_TO_TICKS(100));
  }

  // Get stats
  AttackStats stats = manager.GetStats();
  PentestState state = manager.GetState();

  cJSON* result = cJSON_CreateObject();
  cJSON_AddStringToObject(result, "status", StateToString(state).c_str());
  cJSON_AddNumberToObject(result, "frames_sent", stats.frames_sent);
  cJSON_AddNumberToObject(result, "duration", stats.elapsed_seconds);
  cJSON_AddNumberToObject(result, "errors", stats.errors);
  cJSON_AddStringToObject(result, "message", "Attack completed");

  return result;
}

ReturnValue WifiPentestMcpTools::HandleRogueApAttack(const PropertyList& properties) {
  ESP_LOGI(TAG, "Starting rogue AP attack");

  WifiPentestManager& manager = WifiPentestManager::GetInstance();

  // Initialize manager if not already initialized
  if (!manager.IsInitialized()) {
    esp_err_t ret = manager.Initialize();
    if (ret != ESP_OK) {
      cJSON* error = cJSON_CreateObject();
      cJSON_AddStringToObject(error, "error", "Failed to initialize pentest manager");
      return error;
    }
  }

  AttackConfig config;
  config.type = AttackType::ROGUE_AP;

  // Parse BSSID
  std::string bssid_str = properties["target_bssid"].value<std::string>();
  if (!ParseMacAddress(bssid_str, config.target_bssid)) {
    cJSON* error = cJSON_CreateObject();
    cJSON_AddStringToObject(error, "error", "Invalid BSSID format");
    return error;
  }

  // SSID
  config.target_ssid = properties["target_ssid"].value<std::string>();
  config.channel = properties["channel"].value<int>();
  config.duration_seconds = properties["duration_seconds"].value<int>();

  // Start attack
  esp_err_t ret = manager.StartAttack(config);
  if (ret != ESP_OK) {
    cJSON* error = cJSON_CreateObject();
    cJSON_AddStringToObject(error, "error", "Failed to start attack");
    return error;
  }

  // Wait for completion
  while (manager.GetState() == PentestState::RUNNING) {
    vTaskDelay(pdMS_TO_TICKS(100));
  }

  // Get stats
  AttackStats stats = manager.GetStats();
  PentestState state = manager.GetState();

  cJSON* result = cJSON_CreateObject();
  cJSON_AddStringToObject(result, "status", StateToString(state).c_str());
  cJSON_AddNumberToObject(result, "handshakes_captured", stats.handshakes_captured);
  cJSON_AddNumberToObject(result, "pcap_size_bytes", manager.GetCaptureSize());
  cJSON_AddBoolToObject(result, "export_available", stats.handshakes_captured > 0);
  cJSON_AddStringToObject(result, "message", "Rogue AP attack completed");

  return result;
}

ReturnValue WifiPentestMcpTools::HandlePmkidCapture(const PropertyList& properties) {
  ESP_LOGI(TAG, "Starting PMKID capture");

  WifiPentestManager& manager = WifiPentestManager::GetInstance();

  // Initialize manager if not already initialized
  if (!manager.IsInitialized()) {
    esp_err_t ret = manager.Initialize();
    if (ret != ESP_OK) {
      cJSON* error = cJSON_CreateObject();
      cJSON_AddStringToObject(error, "error", "Failed to initialize pentest manager");
      return error;
    }
  }

  AttackConfig config;
  config.type = AttackType::PMKID_CAPTURE;

  // Parse BSSID
  std::string bssid_str = properties["target_bssid"].value<std::string>();
  if (!ParseMacAddress(bssid_str, config.target_bssid)) {
    cJSON* error = cJSON_CreateObject();
    cJSON_AddStringToObject(error, "error", "Invalid BSSID format");
    return error;
  }

  // Optional SSID
  config.target_ssid = properties["target_ssid"].value<std::string>();
  config.channel = properties["channel"].value<int>();
  config.duration_seconds = properties["duration_seconds"].value<int>();

  // Start attack
  esp_err_t ret = manager.StartAttack(config);
  if (ret != ESP_OK) {
    cJSON* error = cJSON_CreateObject();
    cJSON_AddStringToObject(error, "error", "Failed to start attack");
    return error;
  }

  // Wait for completion
  while (manager.GetState() == PentestState::RUNNING) {
    vTaskDelay(pdMS_TO_TICKS(100));
  }

  // Get stats
  AttackStats stats = manager.GetStats();
  PentestState state = manager.GetState();

  cJSON* result = cJSON_CreateObject();
  cJSON_AddStringToObject(result, "status", StateToString(state).c_str());
  cJSON_AddBoolToObject(result, "pmkid_captured", stats.pmkid_found);

  if (stats.pmkid_found) {
    cJSON_AddStringToObject(result, "pmkid", stats.pmkid.c_str());
    cJSON_AddBoolToObject(result, "hccapx_available", true);
  }

  cJSON_AddStringToObject(result, "message", "PMKID capture completed");

  return result;
}

ReturnValue WifiPentestMcpTools::HandleDosAttack(const PropertyList& properties) {
  ESP_LOGI(TAG, "Starting DoS attack");

  WifiPentestManager& manager = WifiPentestManager::GetInstance();

  // Initialize manager if not already initialized
  if (!manager.IsInitialized()) {
    esp_err_t ret = manager.Initialize();
    if (ret != ESP_OK) {
      cJSON* error = cJSON_CreateObject();
      cJSON_AddStringToObject(error, "error", "Failed to initialize pentest manager");
      return error;
    }
  }

  AttackConfig config;
  config.type = AttackType::DOS;

  // Parse BSSID
  std::string bssid_str = properties["target_bssid"].value<std::string>();
  if (!ParseMacAddress(bssid_str, config.target_bssid)) {
    cJSON* error = cJSON_CreateObject();
    cJSON_AddStringToObject(error, "error", "Invalid BSSID format");
    return error;
  }

  config.duration_seconds = properties["duration_seconds"].value<int>();

  // Start attack
  esp_err_t ret = manager.StartAttack(config);
  if (ret != ESP_OK) {
    cJSON* error = cJSON_CreateObject();
    cJSON_AddStringToObject(error, "error", "Failed to start attack");
    return error;
  }

  // Wait for completion
  while (manager.GetState() == PentestState::RUNNING) {
    vTaskDelay(pdMS_TO_TICKS(100));
  }

  // Get stats
  AttackStats stats = manager.GetStats();
  PentestState state = manager.GetState();

  cJSON* result = cJSON_CreateObject();
  cJSON_AddStringToObject(result, "status", StateToString(state).c_str());
  cJSON_AddNumberToObject(result, "frames_sent", stats.frames_sent);
  cJSON_AddNumberToObject(result, "duration", stats.elapsed_seconds);
  cJSON_AddStringToObject(result, "message", "DoS attack completed");

  return result;
}

ReturnValue WifiPentestMcpTools::HandleStopAttack(const PropertyList& properties) {
  ESP_LOGI(TAG, "Stopping attack");

  WifiPentestManager& manager = WifiPentestManager::GetInstance();
  manager.StopAttack();

  cJSON* result = cJSON_CreateObject();
  cJSON_AddStringToObject(result, "status", "stopped");
  cJSON_AddStringToObject(result, "message", "Attack stopped successfully");

  return result;
}

ReturnValue WifiPentestMcpTools::HandleExportCapture(const PropertyList& properties) {
  ESP_LOGI(TAG, "Exporting capture");

  WifiPentestManager& manager = WifiPentestManager::GetInstance();

  std::string format = properties["format"].value<std::string>();
  bool base64_encode = properties["base64_encode"].value<bool>();

  std::vector<uint8_t> data;

  if (format == "pcap") {
    data = manager.ExportPcap();
  } else if (format == "hccapx") {
    data = manager.ExportHccapx();
  } else {
    cJSON* error = cJSON_CreateObject();
    cJSON_AddStringToObject(error, "error", "Invalid format. Must be 'pcap' or 'hccapx'");
    return error;
  }

  if (data.empty()) {
    cJSON* error = cJSON_CreateObject();
    cJSON_AddStringToObject(error, "error", "No capture data available");
    return error;
  }

  cJSON* result = cJSON_CreateObject();
  cJSON_AddStringToObject(result, "format", format.c_str());
  cJSON_AddNumberToObject(result, "size_bytes", data.size());

  if (base64_encode) {
    std::string encoded = Base64Encode(data);
    cJSON_AddStringToObject(result, "data_base64", encoded.c_str());
  } else {
    cJSON* data_array = cJSON_CreateArray();
    for (uint8_t byte : data) {
      cJSON_AddItemToArray(data_array, cJSON_CreateNumber(byte));
    }
    cJSON_AddItemToObject(result, "data", data_array);
  }

  cJSON_AddStringToObject(result, "message", "Capture exported successfully");

  return result;
}

ReturnValue WifiPentestMcpTools::HandleGetStatus(const PropertyList& properties) {
  ESP_LOGI(TAG, "Getting attack status");

  WifiPentestManager& manager = WifiPentestManager::GetInstance();
  AttackStats stats = manager.GetStats();
  PentestState state = manager.GetState();
  AttackType type = manager.GetAttackType();

  cJSON* result = cJSON_CreateObject();
  cJSON_AddStringToObject(result, "state", StateToString(state).c_str());
  cJSON_AddStringToObject(result, "attack_type", TypeToString(type).c_str());
  cJSON_AddNumberToObject(result, "elapsed_seconds", stats.elapsed_seconds);
  cJSON_AddNumberToObject(result, "frames_sent", stats.frames_sent);
  cJSON_AddNumberToObject(result, "packets_captured", stats.packets_captured);
  cJSON_AddNumberToObject(result, "handshakes_captured", stats.handshakes_captured);
  cJSON_AddBoolToObject(result, "pmkid_captured", stats.pmkid_found);

  if (stats.pmkid_found) {
    cJSON_AddStringToObject(result, "pmkid", stats.pmkid.c_str());
  }

  return result;
}

// Helper functions

bool WifiPentestMcpTools::ParseMacAddress(const std::string& mac_str, uint8_t* mac_bytes) {
  if (mac_str.length() != 17) {  // AA:BB:CC:DD:EE:FF
    return false;
  }

  int values[6];
  int count = std::sscanf(mac_str.c_str(), "%x:%x:%x:%x:%x:%x",
                          &values[0], &values[1], &values[2],
                          &values[3], &values[4], &values[5]);

  if (count != 6) {
    return false;
  }

  for (int i = 0; i < 6; i++) {
    mac_bytes[i] = static_cast<uint8_t>(values[i]);
  }

  return true;
}

std::string WifiPentestMcpTools::FormatMacAddress(const uint8_t* mac_bytes) {
  char buffer[18];
  std::snprintf(buffer, sizeof(buffer), "%02X:%02X:%02X:%02X:%02X:%02X",
                mac_bytes[0], mac_bytes[1], mac_bytes[2],
                mac_bytes[3], mac_bytes[4], mac_bytes[5]);
  return std::string(buffer);
}

std::string WifiPentestMcpTools::AuthModeToString(wifi_auth_mode_t auth_mode) {
  switch (auth_mode) {
    case WIFI_AUTH_OPEN: return "OPEN";
    case WIFI_AUTH_WEP: return "WEP";
    case WIFI_AUTH_WPA_PSK: return "WPA_PSK";
    case WIFI_AUTH_WPA2_PSK: return "WPA2_PSK";
    case WIFI_AUTH_WPA_WPA2_PSK: return "WPA_WPA2_PSK";
    case WIFI_AUTH_WPA2_ENTERPRISE: return "WPA2_ENTERPRISE";
    case WIFI_AUTH_WPA3_PSK: return "WPA3_PSK";
    case WIFI_AUTH_WPA2_WPA3_PSK: return "WPA2_WPA3_PSK";
    default: return "UNKNOWN";
  }
}

std::string WifiPentestMcpTools::StateToString(PentestState state) {
  switch (state) {
    case PentestState::IDLE: return "idle";
    case PentestState::READY: return "ready";
    case PentestState::RUNNING: return "running";
    case PentestState::FINISHED: return "finished";
    case PentestState::TIMEOUT: return "timeout";
    case PentestState::ERROR: return "error";
    case PentestState::ABORTED: return "aborted";
    default: return "unknown";
  }
}

std::string WifiPentestMcpTools::TypeToString(AttackType type) {
  switch (type) {
    case AttackType::NONE: return "none";
    case AttackType::DEAUTH: return "deauth";
    case AttackType::ROGUE_AP: return "rogue_ap";
    case AttackType::PMKID_CAPTURE: return "pmkid";
    case AttackType::DOS: return "dos";
    default: return "unknown";
  }
}

std::string WifiPentestMcpTools::Base64Encode(const std::vector<uint8_t>& data) {
  size_t dlen = 0, olen = 0;

  // Calculate required buffer size
  mbedtls_base64_encode(nullptr, 0, &dlen, data.data(), data.size());

  // Allocate buffer and encode
  std::vector<uint8_t> buffer(dlen);
  mbedtls_base64_encode(buffer.data(), buffer.size(), &olen, data.data(), data.size());

  return std::string(buffer.begin(), buffer.begin() + olen);
}

}  // namespace xiaozhi
