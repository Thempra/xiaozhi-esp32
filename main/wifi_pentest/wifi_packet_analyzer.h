// Copyright 2025 XiaoZhi ESP32 Project
// WiFi Packet Analyzer - Promiscuous Mode Capture & Analysis

#pragma once

#include <cstdint>
#include <functional>
#include <string>
#include <vector>

#include "esp_err.h"
#include "esp_wifi_types.h"

namespace xiaozhi {

// Packet types
enum class PacketType {
  UNKNOWN,
  BEACON,
  PROBE_REQUEST,
  PROBE_RESPONSE,
  DATA,
  EAPOL_HANDSHAKE,
  DEAUTH,
  AUTH
};

// EAPoL handshake message types
enum class EapolMessageType {
  UNKNOWN,
  MSG1,  // ANonce from AP
  MSG2,  // SNonce from client + MIC
  MSG3,  // GTK from AP + MIC
  MSG4   // ACK from client + MIC
};

// Captured packet info
struct CapturedPacket {
  PacketType type;
  uint8_t* data;
  size_t length;
  int64_t timestamp_us;
  int8_t rssi;
  uint8_t channel;

  // For EAPoL packets
  EapolMessageType eapol_type;
  uint8_t source_mac[6];
  uint8_t dest_mac[6];
  uint8_t bssid[6];
};

// Handshake capture result
struct HandshakeCapture {
  bool complete = false;
  uint8_t bssid[6] = {0};
  uint8_t client_mac[6] = {0};
  std::string ssid;
  uint8_t anonce[32] = {0};
  uint8_t snonce[32] = {0};
  uint8_t keymic[16] = {0};
  std::vector<uint8_t> eapol_msg2;
  std::vector<uint8_t> eapol_msg3;
  bool has_msg1 = false;
  bool has_msg2 = false;
  bool has_msg3 = false;
  bool has_msg4 = false;
};

// PMKID capture result
struct PmkidCapture {
  bool found = false;
  uint8_t bssid[6] = {0};
  uint8_t client_mac[6] = {0};
  uint8_t pmkid[16] = {0};
  std::string ssid;
};

// Callback for packet capture
using PacketCallback = std::function<void(const CapturedPacket&)>;

// WiFi Packet Analyzer
class WifiPacketAnalyzer {
 public:
  WifiPacketAnalyzer();
  ~WifiPacketAnalyzer();

  // Lifecycle
  esp_err_t Initialize();
  void Shutdown();
  bool IsInitialized() const { return initialized_; }

  // Capture control
  esp_err_t StartCapture(uint8_t channel);
  esp_err_t StopCapture();
  bool IsCapturing() const { return capturing_; }

  // Packet analysis
  static PacketType IdentifyPacket(const uint8_t* frame, size_t length);
  static bool IsEapolHandshake(const uint8_t* frame, size_t length);
  static EapolMessageType GetEapolMessageType(const uint8_t* frame, size_t length);
  static bool ExtractPmkid(const uint8_t* frame, size_t length, uint8_t* pmkid_out);

  // Handshake detection
  bool HasCompleteHandshake(const uint8_t* target_bssid = nullptr) const;
  HandshakeCapture GetHandshake() const { return handshake_; }

  // PMKID detection
  bool HasPmkid() const { return pmkid_.found; }
  PmkidCapture GetPmkid() const { return pmkid_; }

  // Packet buffer
  std::vector<CapturedPacket> GetCapturedPackets() const;
  size_t GetPacketCount() const { return packet_count_; }
  void ClearBuffer();

  // Callback registration
  void SetPacketCallback(PacketCallback callback);

  // Statistics
  uint32_t GetPacketsCaptured() const { return packet_count_; }
  void ResetStats();

 private:
  // ESP32 promiscuous mode callback
  static void PromiscuousRxCallback(void* buf, wifi_promiscuous_pkt_type_t type);
  void HandlePacket(const uint8_t* frame, size_t length, const wifi_promiscuous_pkt_t* pkt);

  // Handshake processing
  void ProcessEapolPacket(const CapturedPacket& packet);
  void ExtractHandshakeData(const uint8_t* frame, size_t length, EapolMessageType msg_type);

  // PMKID processing
  void ProcessPmkid(const uint8_t* frame, size_t length);

  // Helpers
  void AddToBuffer(const CapturedPacket& packet);

  // State
  bool initialized_ = false;
  bool capturing_ = false;
  uint8_t capture_channel_ = 0;

  // Capture results
  HandshakeCapture handshake_;
  PmkidCapture pmkid_;

  // Packet buffer (circular)
  std::vector<CapturedPacket> packet_buffer_;
  size_t buffer_index_ = 0;
  uint32_t packet_count_ = 0;
  static constexpr size_t MAX_BUFFER_SIZE = 1000;

  // Callback
  PacketCallback packet_callback_;

  // Singleton for static callback
  static WifiPacketAnalyzer* instance_;
};

}  // namespace xiaozhi
