// Copyright 2025 XiaoZhi ESP32 Project
// WiFi Frame Injector - 802.11 Raw Frame Injection

#pragma once

#include <cstdint>
#include <vector>

#include "esp_err.h"
#include "esp_wifi_types.h"

namespace xiaozhi {

// 802.11 Frame types
enum class FrameType {
  DEAUTH = 0xC0,
  BEACON = 0x80,
  PROBE_REQUEST = 0x40,
  PROBE_RESPONSE = 0x50,
  AUTHENTICATION = 0xB0,
  ASSOCIATION_REQUEST = 0x00,
  ASSOCIATION_RESPONSE = 0x10
};

// Deauthentication frame structure (26 bytes)
struct __attribute__((packed)) DeauthFrame {
  uint8_t frame_control[2];    // 0xC0, 0x00
  uint8_t duration[2];         // 0x00, 0x00
  uint8_t destination[6];      // Client MAC or broadcast
  uint8_t source[6];           // BSSID
  uint8_t bssid[6];            // BSSID
  uint8_t sequence[2];         // Sequence number
  uint8_t reason_code[2];      // 0x07, 0x00 (Class 3 frame)
};

// Beacon frame header
struct __attribute__((packed)) BeaconFrameHeader {
  uint8_t frame_control[2];    // 0x80, 0x00
  uint8_t duration[2];         // 0x00, 0x00
  uint8_t destination[6];      // Broadcast FF:FF:FF:FF:FF:FF
  uint8_t source[6];           // BSSID
  uint8_t bssid[6];            // BSSID
  uint8_t sequence[2];         // Sequence number
  uint8_t timestamp[8];        // Timestamp
  uint16_t beacon_interval;    // Usually 100 (100 TU = 102.4ms)
  uint16_t capability;         // Capability info
};

// Rate limiter for frame injection
class RateLimiter {
 public:
  explicit RateLimiter(uint32_t max_fps);

  // Wait if needed to maintain target FPS
  void WaitIfNeeded();

  // Reset timing
  void Reset();

  // Update target FPS
  void SetMaxFps(uint32_t max_fps);

  // Get current target FPS
  uint32_t GetMaxFps() const { return max_fps_; }

 private:
  uint32_t max_fps_;
  int64_t last_frame_time_us_ = 0;
  int64_t frame_interval_us_ = 0;
};

// WiFi Frame Injector
class WifiFrameInjector {
 public:
  WifiFrameInjector();
  ~WifiFrameInjector();

  // Lifecycle
  esp_err_t Initialize();
  void Shutdown();
  bool IsInitialized() const { return initialized_; }

  // Channel control
  esp_err_t SetChannel(uint8_t channel);
  uint8_t GetChannel() const { return current_channel_; }

  // Frame injection
  esp_err_t InjectDeauthFrame(const uint8_t* target_bssid,
                               const uint8_t* client_mac = nullptr);
  esp_err_t InjectBeaconFrame(const uint8_t* bssid,
                               const char* ssid,
                               uint8_t channel);
  esp_err_t InjectRawFrame(const uint8_t* frame, size_t length);

  // Rate limiting
  void SetFrameRate(uint32_t fps);
  uint32_t GetFrameRate() const { return rate_limiter_.GetMaxFps(); }

  // Statistics
  uint32_t GetFramesSent() const { return frames_sent_; }
  uint32_t GetErrors() const { return errors_; }
  void ResetStats();

  // Device MAC
  esp_err_t GetDeviceMac(uint8_t* mac);

 private:
  // Helpers
  uint16_t GetNextSequenceNumber();
  void BuildDeauthFrame(DeauthFrame& frame,
                         const uint8_t* target_bssid,
                         const uint8_t* client_mac);
  std::vector<uint8_t> BuildBeaconFrame(const uint8_t* bssid,
                                         const char* ssid,
                                         uint8_t channel);

  // State
  bool initialized_ = false;
  bool promiscuous_enabled_ = false;
  uint8_t current_channel_ = 1;
  uint16_t sequence_number_ = 0;

  // Statistics
  uint32_t frames_sent_ = 0;
  uint32_t errors_ = 0;

  // Rate limiting
  RateLimiter rate_limiter_;

  friend class RateLimiter;
};

}  // namespace xiaozhi
