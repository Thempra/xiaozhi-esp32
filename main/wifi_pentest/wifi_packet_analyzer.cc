// Copyright 2025 XiaoZhi ESP32 Project
// WiFi Packet Analyzer Implementation

#include "wifi_packet_analyzer.h"

#include <cstring>

#include "esp_log.h"
#include "esp_wifi.h"
#include "wifi_coordinator.h"

static const char* TAG = "PacketAnalyzer";

namespace xiaozhi {

// Static instance for callback
WifiPacketAnalyzer* WifiPacketAnalyzer::instance_ = nullptr;

WifiPacketAnalyzer::WifiPacketAnalyzer() {
  instance_ = this;
  packet_buffer_.reserve(MAX_BUFFER_SIZE);
}

WifiPacketAnalyzer::~WifiPacketAnalyzer() {
  Shutdown();
  instance_ = nullptr;
}

esp_err_t WifiPacketAnalyzer::Initialize() {
  if (initialized_) {
    return ESP_OK;
  }
  
  ESP_LOGI(TAG, "Initializing WiFi Packet Analyzer");
  
  initialized_ = true;
  
  ESP_LOGI(TAG, "Packet analyzer initialized");
  return ESP_OK;
}

void WifiPacketAnalyzer::Shutdown() {
  if (!initialized_) return;
  
  ESP_LOGI(TAG, "Shutting down packet analyzer");
  
  StopCapture();
  ClearBuffer();
  
  initialized_ = false;
}

esp_err_t WifiPacketAnalyzer::StartCapture(uint8_t channel) {
  if (!initialized_) {
    return ESP_ERR_INVALID_STATE;
  }

  if (capturing_) {
    ESP_LOGW(TAG, "Already capturing");
    return ESP_OK;
  }

  ESP_LOGI(TAG, "Starting packet capture on channel %d", channel);

  capture_channel_ = channel;

  auto& coordinator = WifiCoordinator::GetInstance();

  // Set channel (includes deauth in pentest mode)
  esp_err_t ret = coordinator.SetChannel(channel);
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Failed to set channel via coordinator: %s", esp_err_to_name(ret));
    return ret;
  }

  // Enable promiscuous mode (reference counted)
  ret = coordinator.EnablePromiscuous();
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Failed to enable promiscuous via coordinator: %s", esp_err_to_name(ret));
    return ret;
  }

  // Set callback
  esp_wifi_set_promiscuous_rx_cb(PromiscuousRxCallback);

  capturing_ = true;

  ESP_LOGI(TAG, "Packet capture started (promiscuous ref count: %d)",
           coordinator.GetPromiscuousRefCount());
  return ESP_OK;
}

esp_err_t WifiPacketAnalyzer::StopCapture() {
  if (!capturing_) {
    return ESP_OK;
  }

  ESP_LOGI(TAG, "Stopping packet capture");

  // Clear callback first
  esp_wifi_set_promiscuous_rx_cb(nullptr);

  // Disable promiscuous mode via coordinator (reference counted)
  auto& coordinator = WifiCoordinator::GetInstance();
  coordinator.DisablePromiscuous();

  capturing_ = false;

  ESP_LOGI(TAG, "Packet capture stopped (captured %lu packets, promiscuous ref count: %d)",
           packet_count_, coordinator.GetPromiscuousRefCount());
  return ESP_OK;
}

void WifiPacketAnalyzer::PromiscuousRxCallback(void* buf, wifi_promiscuous_pkt_type_t type) {
  if (!instance_) return;
  
  const wifi_promiscuous_pkt_t* pkt = static_cast<wifi_promiscuous_pkt_t*>(buf);
  
  // Only process WIFI packets (not MGMT or DATA separately)
  if (type != WIFI_PKT_MISC && type != WIFI_PKT_DATA && type != WIFI_PKT_MGMT) {
    return;
  }
  
  instance_->HandlePacket(pkt->payload, pkt->rx_ctrl.sig_len, pkt);
}

void WifiPacketAnalyzer::HandlePacket(const uint8_t* frame, size_t length,
                                       const wifi_promiscuous_pkt_t* pkt) {
  if (length < 24) return;  // Minimum 802.11 frame size
  
  CapturedPacket packet;
  packet.type = IdentifyPacket(frame, length);
  packet.data = const_cast<uint8_t*>(frame);  // Note: temporary pointer
  packet.length = length;
  packet.timestamp_us = esp_timer_get_time();
  packet.rssi = pkt ? pkt->rx_ctrl.rssi : 0;
  packet.channel = pkt ? pkt->rx_ctrl.channel : 0;
  
  // Extract MACs
  std::memcpy(packet.dest_mac, frame + 4, 6);
  std::memcpy(packet.source_mac, frame + 10, 6);
  std::memcpy(packet.bssid, frame + 16, 6);
  
  // Check for EAPoL handshake
  if (IsEapolHandshake(frame, length)) {
    packet.eapol_type = GetEapolMessageType(frame, length);
    ProcessEapolPacket(packet);
  }
  
  // Check for PMKID in beacon/probe response
  if (packet.type == PacketType::BEACON || packet.type == PacketType::PROBE_RESPONSE) {
    ProcessPmkid(frame, length);
  }
  
  // Add to buffer
  AddToBuffer(packet);
  
  // Call user callback if registered
  if (packet_callback_) {
    packet_callback_(packet);
  }
  
  packet_count_++;
}

PacketType WifiPacketAnalyzer::IdentifyPacket(const uint8_t* frame, size_t length) {
  if (length < 2) return PacketType::UNKNOWN;
  
  uint8_t frame_type = frame[0];
  uint8_t frame_subtype = frame[0] & 0xF0;
  
  // Management frames
  if ((frame_type & 0x0C) == 0x00) {
    switch (frame_subtype) {
      case 0x80: return PacketType::BEACON;
      case 0x40: return PacketType::PROBE_REQUEST;
      case 0x50: return PacketType::PROBE_RESPONSE;
      case 0xB0: return PacketType::AUTH;
      case 0xC0: return PacketType::DEAUTH;
      default: return PacketType::UNKNOWN;
    }
  }
  
  // Data frames
  if ((frame_type & 0x0C) == 0x08) {
    return PacketType::DATA;
  }
  
  return PacketType::UNKNOWN;
}

bool WifiPacketAnalyzer::IsEapolHandshake(const uint8_t* frame, size_t length) {
  if (length < 38) return false;
  
  // Check if it's a data frame
  if ((frame[0] & 0x0C) != 0x08) return false;
  
  // Find LLC header (after 802.11 header + potential QoS)
  size_t llc_offset = 24;
  if (frame[0] & 0x80) {  // QoS bit
    llc_offset += 2;
  }
  
  if (length < llc_offset + 8) return false;
  
  // Check for 802.1X (EtherType 0x888E)
  if (frame[llc_offset + 6] != 0x88 || frame[llc_offset + 7] != 0x8E) {
    return false;
  }
  
  return true;
}

EapolMessageType WifiPacketAnalyzer::GetEapolMessageType(const uint8_t* frame, size_t length) {
  if (!IsEapolHandshake(frame, length)) {
    return EapolMessageType::UNKNOWN;
  }
  
  size_t llc_offset = 24;
  if (frame[0] & 0x80) llc_offset += 2;
  
  if (length < llc_offset + 12) return EapolMessageType::UNKNOWN;
  
  // EAPoL Key Information field (2 bytes at offset 5-6 after EAPoL header)
  size_t key_info_offset = llc_offset + 8 + 5;
  if (length < key_info_offset + 2) return EapolMessageType::UNKNOWN;
  
  uint16_t key_info = (frame[key_info_offset] << 8) | frame[key_info_offset + 1];
  
  bool is_pairwise = (key_info & 0x0008) != 0;  // Pairwise bit
  bool has_mic = (key_info & 0x0100) != 0;       // MIC bit
  bool is_ack = (key_info & 0x0080) != 0;        // ACK bit
  bool is_install = (key_info & 0x0040) != 0;    // Install bit
  
  // Determine message type based on flags
  if (is_pairwise && is_ack && !has_mic) {
    return EapolMessageType::MSG1;  // ANonce from AP
  } else if (is_pairwise && !is_ack && has_mic) {
    return EapolMessageType::MSG2;  // SNonce from client
  } else if (is_pairwise && is_ack && has_mic && is_install) {
    return EapolMessageType::MSG3;  // GTK from AP
  } else if (is_pairwise && !is_ack && has_mic && !is_install) {
    return EapolMessageType::MSG4;  // ACK from client
  }
  
  return EapolMessageType::UNKNOWN;
}

void WifiPacketAnalyzer::ProcessEapolPacket(const CapturedPacket& packet) {
  ESP_LOGI(TAG, "EAPoL packet detected (type: %d)", (int)packet.eapol_type);
  
  // Extract nonces and MIC based on message type
  size_t llc_offset = 24;
  if (packet.data[0] & 0x80) llc_offset += 2;
  
  size_t eapol_offset = llc_offset + 8;
  
  switch (packet.eapol_type) {
    case EapolMessageType::MSG1:
      // Extract ANonce (32 bytes at offset 17)
      if (packet.length >= eapol_offset + 17 + 32) {
        std::memcpy(handshake_.anonce, packet.data + eapol_offset + 17, 32);
        std::memcpy(handshake_.bssid, packet.source_mac, 6);
        handshake_.has_msg1 = true;
        ESP_LOGI(TAG, "MSG1: ANonce captured");
      }
      break;
      
    case EapolMessageType::MSG2:
      // Extract SNonce and KeyMIC
      if (packet.length >= eapol_offset + 17 + 32) {
        std::memcpy(handshake_.snonce, packet.data + eapol_offset + 17, 32);
        std::memcpy(handshake_.client_mac, packet.source_mac, 6);
        
        // KeyMIC is at offset 77 (16 bytes)
        if (packet.length >= eapol_offset + 77 + 16) {
          std::memcpy(handshake_.keymic, packet.data + eapol_offset + 77, 16);
        }
        
        // Store full MSG2
        handshake_.eapol_msg2.assign(packet.data, packet.data + packet.length);
        handshake_.has_msg2 = true;
        ESP_LOGI(TAG, "MSG2: SNonce and MIC captured");
      }
      break;
      
    case EapolMessageType::MSG3:
      // Store full MSG3
      handshake_.eapol_msg3.assign(packet.data, packet.data + packet.length);
      handshake_.has_msg3 = true;
      ESP_LOGI(TAG, "MSG3 captured");
      break;
      
    case EapolMessageType::MSG4:
      handshake_.has_msg4 = true;
      ESP_LOGI(TAG, "MSG4 captured");
      break;
      
    default:
      break;
  }
  
  // Check if we have a complete 4-way handshake
  if (handshake_.has_msg1 && handshake_.has_msg2 &&
      handshake_.has_msg3 && handshake_.has_msg4) {
    handshake_.complete = true;
    ESP_LOGI(TAG, "Complete 4-way handshake captured!");
  }
}

bool WifiPacketAnalyzer::ExtractPmkid(const uint8_t* frame, size_t length, uint8_t* pmkid_out) {
  if (length < 36) return false;
  
  // Look for RSN IE (Tag 48 = 0x30)
  size_t offset = 36;  // After beacon/probe response fixed parameters
  
  while (offset + 2 < length) {
    uint8_t tag = frame[offset];
    uint8_t tag_len = frame[offset + 1];
    
    if (offset + 2 + tag_len > length) break;
    
    if (tag == 0x30) {  // RSN IE
      // PMKID is in the RSN IE, typically at the end
      // Format: version(2) + group cipher(4) + pairwise count(2) + pairwise cipher(4) + 
      //         akm count(2) + akm suite(4) + RSN capabilities(2) + PMKID count(2) + PMKID(16)
      
      if (tag_len >= 20) {  // Minimum RSN IE with PMKID
        size_t rsn_offset = offset + 2;
        
        // Skip to end of RSN IE to find PMKID
        // This is simplified - real implementation would parse the structure
        if (tag_len >= 38 && frame[rsn_offset + tag_len - 18] == 0x01) {
          // Found PMKID count = 1
          std::memcpy(pmkid_out, frame + rsn_offset + tag_len - 16, 16);
          return true;
        }
      }
    }
    
    offset += 2 + tag_len;
  }
  
  return false;
}

void WifiPacketAnalyzer::ProcessPmkid(const uint8_t* frame, size_t length) {
  if (pmkid_.found) return;  // Already captured
  
  uint8_t pmkid_bytes[16];
  if (ExtractPmkid(frame, length, pmkid_bytes)) {
    std::memcpy(pmkid_.pmkid, pmkid_bytes, 16);
    std::memcpy(pmkid_.bssid, frame + 16, 6);  // BSSID from frame
    pmkid_.found = true;
    
    ESP_LOGI(TAG, "PMKID captured from beacon/probe response");
  }
}

bool WifiPacketAnalyzer::HasCompleteHandshake(const uint8_t* target_bssid) const {
  if (!handshake_.complete) return false;
  
  if (target_bssid) {
    return std::memcmp(handshake_.bssid, target_bssid, 6) == 0;
  }
  
  return true;
}

void WifiPacketAnalyzer::AddToBuffer(const CapturedPacket& packet) {
  // Circular buffer
  if (packet_buffer_.size() < MAX_BUFFER_SIZE) {
    packet_buffer_.push_back(packet);
  } else {
    packet_buffer_[buffer_index_] = packet;
    buffer_index_ = (buffer_index_ + 1) % MAX_BUFFER_SIZE;
  }
}

std::vector<CapturedPacket> WifiPacketAnalyzer::GetCapturedPackets() const {
  return packet_buffer_;
}

void WifiPacketAnalyzer::ClearBuffer() {
  packet_buffer_.clear();
  buffer_index_ = 0;
  packet_count_ = 0;
  
  // Clear captures
  handshake_ = HandshakeCapture{};
  pmkid_ = PmkidCapture{};
}

void WifiPacketAnalyzer::SetPacketCallback(PacketCallback callback) {
  packet_callback_ = callback;
}

void WifiPacketAnalyzer::ResetStats() {
  packet_count_ = 0;
}

}  // namespace xiaozhi
