// Copyright 2025 XiaoZhi ESP32 Project
// HCCAPX Writer Implementation

#include "hccapx_writer.h"

#include <cstring>
#include <iomanip>
#include <sstream>

#include "esp_log.h"
#include "../wifi_packet_analyzer.h"

static const char* TAG = "HccapxWriter";

namespace xiaozhi {

HccapxWriter::HccapxWriter() {}

bool HccapxWriter::WriteHandshake(const HandshakeCapture& handshake) {
  if (!handshake.complete) {
    ESP_LOGW(TAG, "Handshake not complete");
    return false;
  }
  
  buffer_.clear();
  
  HccapxRecord record;
  std::memset(&record, 0, sizeof(record));
  
  // Signature: 'HCPX' (0x58504348)
  record.signature = 0x58504348;
  
  // Version 4
  record.version = 4;
  
  // Message pair bitmask
  record.message_pair = 0;
  if (handshake.has_msg1) record.message_pair |= 0x80;
  if (handshake.has_msg2) record.message_pair |= 0x40;
  if (handshake.has_msg3) record.message_pair |= 0x20;
  if (handshake.has_msg4) record.message_pair |= 0x10;
  
  // ESSID
  record.essid_len = std::min((size_t)32, handshake.ssid.length());
  std::memcpy(record.essid, handshake.ssid.c_str(), record.essid_len);
  
  // Key version (assume WPA2 = 2)
  record.keyver = 2;
  
  // Key MIC
  std::memcpy(record.keymic, handshake.keymic, 16);
  
  // MAC addresses
  std::memcpy(record.mac_ap, handshake.bssid, 6);
  std::memcpy(record.mac_sta, handshake.client_mac, 6);
  
  // Nonces
  std::memcpy(record.nonce_ap, handshake.anonce, 32);
  std::memcpy(record.nonce_sta, handshake.snonce, 32);
  
  // EAPOL frame (from MSG2, truncated to 256 bytes)
  if (!handshake.eapol_msg2.empty()) {
    size_t eapol_len = std::min((size_t)256, handshake.eapol_msg2.size());
    record.eapol_len = eapol_len;
    std::memcpy(record.eapol, handshake.eapol_msg2.data(), eapol_len);
  }
  
  // Write to buffer
  uint8_t* record_bytes = reinterpret_cast<uint8_t*>(&record);
  buffer_.assign(record_bytes, record_bytes + sizeof(record));
  
  has_data_ = true;
  
  ESP_LOGI(TAG, "HCCAPX handshake record created (%d bytes)", buffer_.size());
  return true;
}

bool HccapxWriter::WritePmkid(const PmkidCapture& pmkid) {
  if (!pmkid.found) {
    ESP_LOGW(TAG, "PMKID not found");
    return false;
  }
  
  buffer_.clear();
  
  PmkidRecord record;
  std::memset(&record, 0, sizeof(record));
  
  // Signature: 'HCPX'
  record.signature = 0x58504348;
  
  // Version 4
  record.version = 4;
  
  // PMKID
  std::memcpy(record.pmkid, pmkid.pmkid, 16);
  
  // MAC addresses
  std::memcpy(record.mac_ap, pmkid.bssid, 6);
  std::memcpy(record.mac_sta, pmkid.client_mac, 6);
  
  // ESSID
  record.essid_len = std::min((size_t)32, pmkid.ssid.length());
  std::memcpy(record.essid, pmkid.ssid.c_str(), record.essid_len);
  
  // Write to buffer
  uint8_t* record_bytes = reinterpret_cast<uint8_t*>(&record);
  buffer_.assign(record_bytes, record_bytes + sizeof(record));
  
  has_data_ = true;
  
  ESP_LOGI(TAG, "HCCAPX PMKID record created (%d bytes)", buffer_.size());
  return true;
}

std::vector<uint8_t> HccapxWriter::Export() const {
  return buffer_;
}

std::string HccapxWriter::ExportHex() const {
  std::stringstream ss;
  
  for (size_t i = 0; i < buffer_.size(); i++) {
    ss << std::hex << std::setfill('0') << std::setw(2) << (int)buffer_[i];
  }
  
  return ss.str();
}

void HccapxWriter::Clear() {
  buffer_.clear();
  has_data_ = false;
}

}  // namespace xiaozhi
